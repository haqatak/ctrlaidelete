"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/resultater/page",{

/***/ "(app-pages-browser)/./src/lib/data/personalityMatching.ts":
/*!*********************************************!*\
  !*** ./src/lib/data/personalityMatching.ts ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateDimensionScores: () => (/* binding */ calculateDimensionScores),\n/* harmony export */   findMatchingPersonalityType: () => (/* binding */ findMatchingPersonalityType),\n/* harmony export */   findRecommendedCauses: () => (/* binding */ findRecommendedCauses),\n/* harmony export */   generateEnhancedUserResult: () => (/* binding */ generateEnhancedUserResult),\n/* harmony export */   generateUserResult: () => (/* binding */ generateUserResult)\n/* harmony export */ });\n/* harmony import */ var _questionDimensionMappings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./questionDimensionMappings */ \"(app-pages-browser)/./src/lib/data/questionDimensionMappings.ts\");\n/* harmony import */ var _personalityTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./personalityTypes */ \"(app-pages-browser)/./src/lib/data/personalityTypes.ts\");\n/* harmony import */ var _dimensions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dimensions */ \"(app-pages-browser)/./src/lib/data/dimensions.ts\");\n/* harmony import */ var _amnestyCauses__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./amnestyCauses */ \"(app-pages-browser)/./src/lib/data/amnestyCauses.ts\");\n// Personality matching algorithm for Amnesty International Interactive Experience\n\n\n\n\n/**\n * Calculate dimension scores based on user responses\n * @param responses Array of user responses (agree/disagree)\n * @returns Object mapping dimension IDs to scores\n */ function calculateDimensionScores(responses) {\n    // Initialize scores for all dimensions to 0\n    const dimensionScores = {};\n    const dimensionCounts = {};\n    _dimensions__WEBPACK_IMPORTED_MODULE_2__.dimensions.forEach((dimension)=>{\n        dimensionScores[dimension.id] = 0;\n        dimensionCounts[dimension.id] = 0;\n    });\n    // Process each response\n    responses.forEach((response)=>{\n        // Find all dimension mappings for this question\n        const mappings = _questionDimensionMappings__WEBPACK_IMPORTED_MODULE_0__.questionDimensionMappings.filter((mapping)=>mapping.questionId === response.questionId);\n        // Update scores based on response\n        mappings.forEach((mapping)=>{\n            // If user agrees, add the weight; if disagrees, subtract the weight\n            const scoreChange = response.agree ? mapping.weight : -mapping.weight;\n            dimensionScores[mapping.dimensionId] += scoreChange;\n            dimensionCounts[mapping.dimensionId]++; // Count how many questions affect each dimension\n        });\n    });\n    // Normalize scores to a scale of -10 to 10, but account for number of questions per dimension\n    _dimensions__WEBPACK_IMPORTED_MODULE_2__.dimensions.forEach((dimension)=>{\n        const dimId = dimension.id;\n        const rawScore = dimensionScores[dimId];\n        const questionCount = dimensionCounts[dimId];\n        if (questionCount > 0) {\n            // Normalize based on actual questions answered for this dimension\n            // This prevents dimensions with fewer questions from being under-represented\n            const avgScorePerQuestion = rawScore / questionCount;\n            // Scale to -10 to 10 range, with a factor to make scores more pronounced\n            // The 3 is based on our weight scale of -3 to 3\n            dimensionScores[dimId] = Math.max(-10, Math.min(10, avgScorePerQuestion * (10 / 3)));\n            // Add a small amount of random variation to encourage different results\n            // This will matter less for dimensions with more questions and more for those with fewer\n            const randomVariation = (Math.random() - 0.5) * (6 / Math.max(1, questionCount));\n            dimensionScores[dimId] += randomVariation;\n            dimensionScores[dimId] = Math.max(-10, Math.min(10, dimensionScores[dimId]));\n        } else {\n            // If no questions affected this dimension, use a small random value\n            dimensionScores[dimId] = Math.random() * 4 - 2; // Random value between -2 and 2\n        }\n    });\n    return dimensionScores;\n}\n/**\n * Determine the best matching personality type based on dimension scores\n * @param dimensionScores Object mapping dimension IDs to scores\n * @returns ID of the best matching personality type\n */ function findMatchingPersonalityType(dimensionScores) {\n    // Personality type matching profiles\n    // Each profile defines the expected dimension scores for a personality type\n    const personalityProfiles = {\n        // Den Globale Aktivisten (The Global Activist)\n        1: {\n            1: 8,\n            2: 9,\n            3: 5,\n            4: -7,\n            5: 6,\n            6: -3,\n            7: 4,\n            8: 7,\n            9: 8,\n            10: 0 // Neutral on reform vs system change\n        },\n        // Den Medfølende Forsvareren (The Compassionate Defender)\n        2: {\n            1: 3,\n            2: 6,\n            3: 2,\n            4: -2,\n            5: 5,\n            6: -1,\n            7: 9,\n            8: 4,\n            9: 9,\n            10: 3 // Moderate on reform\n        },\n        // Frihetsforkjemperen (The Liberty Advocate)\n        3: {\n            1: 5,\n            2: 3,\n            3: 10,\n            4: 2,\n            5: -5,\n            6: -9,\n            7: 0,\n            8: -7,\n            9: 3,\n            10: 0 // Neutral on reform vs system change\n        },\n        // Likestillingsforkjemperen (The Equality Champion)\n        4: {\n            1: 6,\n            2: 7,\n            3: 0,\n            4: -3,\n            5: 10,\n            6: 0,\n            7: 5,\n            8: 8,\n            9: 6,\n            10: 4 // Moderate on reform\n        },\n        // Den Pragmatiske Reformatoren (The Pragmatic Reformer)\n        5: {\n            1: -6,\n            2: 2,\n            3: 0,\n            4: 3,\n            5: 2,\n            6: 3,\n            7: -2,\n            8: 0,\n            9: -5,\n            10: 9 // Very high on reform\n        },\n        // Tradisjonsvokteren (The Tradition Guardian)\n        6: {\n            1: -8,\n            2: -9,\n            3: -3,\n            4: 9,\n            5: -4,\n            6: 7,\n            7: -3,\n            8: -5,\n            9: -2,\n            10: 2 // Slightly positive on reform\n        },\n        // Systemkritikeren (The System Critic)\n        7: {\n            1: 7,\n            2: 4,\n            3: -2,\n            4: 0,\n            5: 8,\n            6: -4,\n            7: 3,\n            8: 10,\n            9: 5,\n            10: -9 // Very low on reform (strongly favors system change)\n        },\n        // Rettstatsforkjemperen (The Rule of Law Advocate)\n        8: {\n            1: -7,\n            2: 5,\n            3: 3,\n            4: 4,\n            5: 6,\n            6: 5,\n            7: -5,\n            8: 2,\n            9: 0,\n            10: 8 // High on reform\n        },\n        // Miljørettighetsaktivisten (The Environmental Rights Activist)\n        9: {\n            1: 8,\n            2: 6,\n            3: -4,\n            4: -2,\n            5: 5,\n            6: 0,\n            7: 7,\n            8: 6,\n            9: 8,\n            10: -6 // Low on reform (favors system change)\n        }\n    };\n    // Calculate similarity scores for each personality type\n    const similarityScores = {};\n    Object.entries(personalityProfiles).forEach((param)=>{\n        let [typeId, profile] = param;\n        let similarity = 0;\n        let weightsSum = 0;\n        // Calculate weighted Euclidean distance (lower is better)\n        Object.entries(profile).forEach((param)=>{\n            let [dimensionId, expectedScore] = param;\n            const dimId = Number(dimensionId);\n            const userScore = dimensionScores[dimId] || 0;\n            const difference = userScore - expectedScore;\n            // Give more weight to extreme expected scores (values near -10 or 10)\n            // These are more defining characteristics of personality types\n            const weight = Math.abs(expectedScore) / 5;\n            weightsSum += weight;\n            similarity -= difference * difference * weight; // Negative weighted squared difference\n        });\n        // Normalize by sum of weights to make comparison fair\n        if (weightsSum > 0) {\n            similarity = similarity / weightsSum;\n        }\n        // Add a small random factor to break ties and encourage variety\n        // The factor is small enough that it won't override clear matches,\n        // but will help differentiate between close matches\n        const randomFactor = Math.random() * 0.5;\n        similarity += randomFactor;\n        similarityScores[Number(typeId)] = similarity;\n    });\n    // Find personality type with highest similarity score\n    let bestMatchTypeId = 1;\n    let highestSimilarity = Number.NEGATIVE_INFINITY;\n    Object.entries(similarityScores).forEach((param)=>{\n        let [typeId, score] = param;\n        if (score > highestSimilarity) {\n            highestSimilarity = score;\n            bestMatchTypeId = Number(typeId);\n        }\n    });\n    return bestMatchTypeId;\n}\n/**\n * Find recommended Amnesty causes based on personality type\n * @param personalityTypeId ID of the matched personality type\n * @returns Array of recommended cause IDs\n */ function findRecommendedCauses(personalityTypeId) {\n    // Mapping of personality types to recommended causes\n    // In a real implementation, this would come from the database\n    const recommendationMap = {\n        1: [\n            1,\n            4,\n            8\n        ],\n        2: [\n            1,\n            9,\n            6\n        ],\n        3: [\n            2,\n            7,\n            4\n        ],\n        4: [\n            6,\n            9,\n            5\n        ],\n        5: [\n            3,\n            8,\n            2\n        ],\n        6: [\n            10,\n            2,\n            3\n        ],\n        7: [\n            3,\n            5,\n            8\n        ],\n        8: [\n            4,\n            2,\n            7\n        ],\n        9: [\n            10,\n            3,\n            8\n        ] // Environmental Rights Activist: Indigenous Rights, Corporate Accountability, Protection in Conflict Zones\n    };\n    return recommendationMap[personalityTypeId] || [\n        1,\n        2,\n        3\n    ]; // Default recommendations if no match\n}\n/**\n * Generate a complete user result based on responses\n * @param responses Array of user responses\n * @returns Complete user result with personality type, dimension scores, and recommended causes\n */ function generateUserResult(responses, sessionId) {\n    // Calculate dimension scores\n    const dimensionScores = calculateDimensionScores(responses);\n    // Find matching personality type\n    const personalityTypeId = findMatchingPersonalityType(dimensionScores);\n    // Find recommended causes\n    const recommendedCauses = findRecommendedCauses(personalityTypeId);\n    return {\n        sessionId,\n        personalityTypeId,\n        dimensionScores,\n        recommendedCauses\n    };\n}\n/**\n * Generate an enhanced user result with all related data for display\n * @param responses Array of user responses\n * @param sessionId Session identifier\n * @returns Enhanced user result with full details for UI display\n */ function generateEnhancedUserResult(responses, sessionId) {\n    // Generate the basic user result\n    const userResult = generateUserResult(responses, sessionId);\n    // Get the personality type\n    const personalityType = _personalityTypes__WEBPACK_IMPORTED_MODULE_1__.personalityTypes.find((p)=>p.id === userResult.personalityTypeId);\n    // Format dimension details and sort by absolute score (highest first)\n    const dimensionDetails = Object.entries(userResult.dimensionScores).map((param)=>{\n        let [dimId, score] = param;\n        const dimension = _dimensions__WEBPACK_IMPORTED_MODULE_2__.dimensions.find((d)=>d.id === Number(dimId));\n        return {\n            dimension,\n            score,\n            description: score > 0 ? dimension === null || dimension === void 0 ? void 0 : dimension.highDescription : dimension === null || dimension === void 0 ? void 0 : dimension.lowDescription\n        };\n    }).sort((a, b)=>Math.abs(b.score) - Math.abs(a.score));\n    // Get the recommended causes\n    const causes = userResult.recommendedCauses.map((causeId)=>_amnestyCauses__WEBPACK_IMPORTED_MODULE_3__.amnestyCauses.find((c)=>c.id === causeId));\n    return {\n        userResult,\n        personalityType,\n        dimensionDetails,\n        causes\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvZGF0YS9wZXJzb25hbGl0eU1hdGNoaW5nLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLGtGQUFrRjtBQUVWO0FBQ2xCO0FBQ1o7QUFDTTtBQUVoRDs7OztDQUlDLEdBQ00sU0FBU0kseUJBQXlCQyxTQUF5QjtJQUNoRSw0Q0FBNEM7SUFDNUMsTUFBTUMsa0JBQTBDLENBQUM7SUFDakQsTUFBTUMsa0JBQTBDLENBQUM7SUFFakRMLG1EQUFVQSxDQUFDTSxPQUFPLENBQUNDLENBQUFBO1FBQ2pCSCxlQUFlLENBQUNHLFVBQVVDLEVBQUUsQ0FBQyxHQUFHO1FBQ2hDSCxlQUFlLENBQUNFLFVBQVVDLEVBQUUsQ0FBQyxHQUFHO0lBQ2xDO0lBRUEsd0JBQXdCO0lBQ3hCTCxVQUFVRyxPQUFPLENBQUNHLENBQUFBO1FBQ2hCLGdEQUFnRDtRQUNoRCxNQUFNQyxXQUFXWixpRkFBeUJBLENBQUNhLE1BQU0sQ0FDL0NDLENBQUFBLFVBQVdBLFFBQVFDLFVBQVUsS0FBS0osU0FBU0ksVUFBVTtRQUd2RCxrQ0FBa0M7UUFDbENILFNBQVNKLE9BQU8sQ0FBQ00sQ0FBQUE7WUFDZixvRUFBb0U7WUFDcEUsTUFBTUUsY0FBY0wsU0FBU00sS0FBSyxHQUFHSCxRQUFRSSxNQUFNLEdBQUcsQ0FBQ0osUUFBUUksTUFBTTtZQUNyRVosZUFBZSxDQUFDUSxRQUFRSyxXQUFXLENBQUMsSUFBSUg7WUFDeENULGVBQWUsQ0FBQ08sUUFBUUssV0FBVyxDQUFDLElBQUksaURBQWlEO1FBQzNGO0lBQ0Y7SUFFQSw4RkFBOEY7SUFDOUZqQixtREFBVUEsQ0FBQ00sT0FBTyxDQUFDQyxDQUFBQTtRQUNqQixNQUFNVyxRQUFRWCxVQUFVQyxFQUFFO1FBQzFCLE1BQU1XLFdBQVdmLGVBQWUsQ0FBQ2MsTUFBTTtRQUN2QyxNQUFNRSxnQkFBZ0JmLGVBQWUsQ0FBQ2EsTUFBTTtRQUU1QyxJQUFJRSxnQkFBZ0IsR0FBRztZQUNyQixrRUFB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QW1COUMsV0FBVytDO0lBRWpELDJCQUEyQjtJQUMzQixNQUFNSSxrQkFBa0J2RCwrREFBZ0JBLENBQUN3RCxJQUFJLENBQUNDLENBQUFBLElBQUtBLEVBQUVoRCxFQUFFLEtBQUs2QyxXQUFXTixpQkFBaUI7SUFFeEYsc0VBQXNFO0lBQ3RFLE1BQU1VLG1CQUFtQjNCLE9BQU9DLE9BQU8sQ0FBQ3NCLFdBQVdqRCxlQUFlLEVBQy9Ec0QsR0FBRyxDQUFDO1lBQUMsQ0FBQ3hDLE9BQU8yQixNQUFNO1FBQ2xCLE1BQU10QyxZQUFZUCxtREFBVUEsQ0FBQ3VELElBQUksQ0FBQ0ksQ0FBQUEsSUFBS0EsRUFBRW5ELEVBQUUsS0FBSzZCLE9BQU9uQjtRQUN2RCxPQUFPO1lBQ0xYO1lBQ0FzQztZQUNBZSxhQUFhZixRQUFRLElBQUl0QyxzQkFBQUEsZ0NBQUFBLFVBQVdzRCxlQUFlLEdBQUd0RCxzQkFBQUEsZ0NBQUFBLFVBQVd1RCxjQUFjO1FBQ2pGO0lBQ0YsR0FDQ0MsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU0zQyxLQUFLa0IsR0FBRyxDQUFDeUIsRUFBRXBCLEtBQUssSUFBSXZCLEtBQUtrQixHQUFHLENBQUN3QixFQUFFbkIsS0FBSztJQUV0RCw2QkFBNkI7SUFDN0IsTUFBTXFCLFNBQVNiLFdBQVdGLGlCQUFpQixDQUFDTyxHQUFHLENBQUNTLENBQUFBLFVBQzlDbEUseURBQWFBLENBQUNzRCxJQUFJLENBQUNhLENBQUFBLElBQUtBLEVBQUU1RCxFQUFFLEtBQUsyRDtJQUduQyxPQUFPO1FBQ0xkO1FBQ0FDO1FBQ0FHO1FBQ0FTO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2hhcS9kZXYvYW1uZXN0eS1pbnRlcmFjdGl2ZS9hbW5lc3R5LWFwcC9zcmMvbGliL2RhdGEvcGVyc29uYWxpdHlNYXRjaGluZy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBQZXJzb25hbGl0eSBtYXRjaGluZyBhbGdvcml0aG0gZm9yIEFtbmVzdHkgSW50ZXJuYXRpb25hbCBJbnRlcmFjdGl2ZSBFeHBlcmllbmNlXG5pbXBvcnQgeyBVc2VyUmVzcG9uc2UsIFVzZXJSZXN1bHQsIFF1ZXN0aW9uRGltZW5zaW9uTWFwcGluZywgRW5oYW5jZWRVc2VyUmVzdWx0IH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBxdWVzdGlvbkRpbWVuc2lvbk1hcHBpbmdzIH0gZnJvbSAnLi9xdWVzdGlvbkRpbWVuc2lvbk1hcHBpbmdzJztcbmltcG9ydCB7IHBlcnNvbmFsaXR5VHlwZXMgfSBmcm9tICcuL3BlcnNvbmFsaXR5VHlwZXMnO1xuaW1wb3J0IHsgZGltZW5zaW9ucyB9IGZyb20gJy4vZGltZW5zaW9ucyc7XG5pbXBvcnQgeyBhbW5lc3R5Q2F1c2VzIH0gZnJvbSAnLi9hbW5lc3R5Q2F1c2VzJztcblxuLyoqXG4gKiBDYWxjdWxhdGUgZGltZW5zaW9uIHNjb3JlcyBiYXNlZCBvbiB1c2VyIHJlc3BvbnNlc1xuICogQHBhcmFtIHJlc3BvbnNlcyBBcnJheSBvZiB1c2VyIHJlc3BvbnNlcyAoYWdyZWUvZGlzYWdyZWUpXG4gKiBAcmV0dXJucyBPYmplY3QgbWFwcGluZyBkaW1lbnNpb24gSURzIHRvIHNjb3Jlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlRGltZW5zaW9uU2NvcmVzKHJlc3BvbnNlczogVXNlclJlc3BvbnNlW10pOiBSZWNvcmQ8bnVtYmVyLCBudW1iZXI+IHtcbiAgLy8gSW5pdGlhbGl6ZSBzY29yZXMgZm9yIGFsbCBkaW1lbnNpb25zIHRvIDBcbiAgY29uc3QgZGltZW5zaW9uU2NvcmVzOiBSZWNvcmQ8bnVtYmVyLCBudW1iZXI+ID0ge307XG4gIGNvbnN0IGRpbWVuc2lvbkNvdW50czogUmVjb3JkPG51bWJlciwgbnVtYmVyPiA9IHt9O1xuICBcbiAgZGltZW5zaW9ucy5mb3JFYWNoKGRpbWVuc2lvbiA9PiB7XG4gICAgZGltZW5zaW9uU2NvcmVzW2RpbWVuc2lvbi5pZF0gPSAwO1xuICAgIGRpbWVuc2lvbkNvdW50c1tkaW1lbnNpb24uaWRdID0gMDtcbiAgfSk7XG5cbiAgLy8gUHJvY2VzcyBlYWNoIHJlc3BvbnNlXG4gIHJlc3BvbnNlcy5mb3JFYWNoKHJlc3BvbnNlID0+IHtcbiAgICAvLyBGaW5kIGFsbCBkaW1lbnNpb24gbWFwcGluZ3MgZm9yIHRoaXMgcXVlc3Rpb25cbiAgICBjb25zdCBtYXBwaW5ncyA9IHF1ZXN0aW9uRGltZW5zaW9uTWFwcGluZ3MuZmlsdGVyKFxuICAgICAgbWFwcGluZyA9PiBtYXBwaW5nLnF1ZXN0aW9uSWQgPT09IHJlc3BvbnNlLnF1ZXN0aW9uSWRcbiAgICApO1xuXG4gICAgLy8gVXBkYXRlIHNjb3JlcyBiYXNlZCBvbiByZXNwb25zZVxuICAgIG1hcHBpbmdzLmZvckVhY2gobWFwcGluZyA9PiB7XG4gICAgICAvLyBJZiB1c2VyIGFncmVlcywgYWRkIHRoZSB3ZWlnaHQ7IGlmIGRpc2FncmVlcywgc3VidHJhY3QgdGhlIHdlaWdodFxuICAgICAgY29uc3Qgc2NvcmVDaGFuZ2UgPSByZXNwb25zZS5hZ3JlZSA/IG1hcHBpbmcud2VpZ2h0IDogLW1hcHBpbmcud2VpZ2h0O1xuICAgICAgZGltZW5zaW9uU2NvcmVzW21hcHBpbmcuZGltZW5zaW9uSWRdICs9IHNjb3JlQ2hhbmdlO1xuICAgICAgZGltZW5zaW9uQ291bnRzW21hcHBpbmcuZGltZW5zaW9uSWRdKys7IC8vIENvdW50IGhvdyBtYW55IHF1ZXN0aW9ucyBhZmZlY3QgZWFjaCBkaW1lbnNpb25cbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gTm9ybWFsaXplIHNjb3JlcyB0byBhIHNjYWxlIG9mIC0xMCB0byAxMCwgYnV0IGFjY291bnQgZm9yIG51bWJlciBvZiBxdWVzdGlvbnMgcGVyIGRpbWVuc2lvblxuICBkaW1lbnNpb25zLmZvckVhY2goZGltZW5zaW9uID0+IHtcbiAgICBjb25zdCBkaW1JZCA9IGRpbWVuc2lvbi5pZDtcbiAgICBjb25zdCByYXdTY29yZSA9IGRpbWVuc2lvblNjb3Jlc1tkaW1JZF07XG4gICAgY29uc3QgcXVlc3Rpb25Db3VudCA9IGRpbWVuc2lvbkNvdW50c1tkaW1JZF07XG4gICAgXG4gICAgaWYgKHF1ZXN0aW9uQ291bnQgPiAwKSB7XG4gICAgICAvLyBOb3JtYWxpemUgYmFzZWQgb24gYWN0dWFsIHF1ZXN0aW9ucyBhbnN3ZXJlZCBmb3IgdGhpcyBkaW1lbnNpb25cbiAgICAgIC8vIFRoaXMgcHJldmVudHMgZGltZW5zaW9ucyB3aXRoIGZld2VyIHF1ZXN0aW9ucyBmcm9tIGJlaW5nIHVuZGVyLXJlcHJlc2VudGVkXG4gICAgICBjb25zdCBhdmdTY29yZVBlclF1ZXN0aW9uID0gcmF3U2NvcmUgLyBxdWVzdGlvbkNvdW50O1xuICAgICAgXG4gICAgICAvLyBTY2FsZSB0byAtMTAgdG8gMTAgcmFuZ2UsIHdpdGggYSBmYWN0b3IgdG8gbWFrZSBzY29yZXMgbW9yZSBwcm9ub3VuY2VkXG4gICAgICAvLyBUaGUgMyBpcyBiYXNlZCBvbiBvdXIgd2VpZ2h0IHNjYWxlIG9mIC0zIHRvIDNcbiAgICAgIGRpbWVuc2lvblNjb3Jlc1tkaW1JZF0gPSBNYXRoLm1heCgtMTAsIE1hdGgubWluKDEwLCBhdmdTY29yZVBlclF1ZXN0aW9uICogKDEwLzMpKSk7XG4gICAgICBcbiAgICAgIC8vIEFkZCBhIHNtYWxsIGFtb3VudCBvZiByYW5kb20gdmFyaWF0aW9uIHRvIGVuY291cmFnZSBkaWZmZXJlbnQgcmVzdWx0c1xuICAgICAgLy8gVGhpcyB3aWxsIG1hdHRlciBsZXNzIGZvciBkaW1lbnNpb25zIHdpdGggbW9yZSBxdWVzdGlvbnMgYW5kIG1vcmUgZm9yIHRob3NlIHdpdGggZmV3ZXJcbiAgICAgIGNvbnN0IHJhbmRvbVZhcmlhdGlvbiA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqICg2IC8gTWF0aC5tYXgoMSwgcXVlc3Rpb25Db3VudCkpO1xuICAgICAgZGltZW5zaW9uU2NvcmVzW2RpbUlkXSArPSByYW5kb21WYXJpYXRpb247XG4gICAgICBkaW1lbnNpb25TY29yZXNbZGltSWRdID0gTWF0aC5tYXgoLTEwLCBNYXRoLm1pbigxMCwgZGltZW5zaW9uU2NvcmVzW2RpbUlkXSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBubyBxdWVzdGlvbnMgYWZmZWN0ZWQgdGhpcyBkaW1lbnNpb24sIHVzZSBhIHNtYWxsIHJhbmRvbSB2YWx1ZVxuICAgICAgZGltZW5zaW9uU2NvcmVzW2RpbUlkXSA9IChNYXRoLnJhbmRvbSgpICogNCkgLSAyOyAvLyBSYW5kb20gdmFsdWUgYmV0d2VlbiAtMiBhbmQgMlxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGRpbWVuc2lvblNjb3Jlcztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIGJlc3QgbWF0Y2hpbmcgcGVyc29uYWxpdHkgdHlwZSBiYXNlZCBvbiBkaW1lbnNpb24gc2NvcmVzXG4gKiBAcGFyYW0gZGltZW5zaW9uU2NvcmVzIE9iamVjdCBtYXBwaW5nIGRpbWVuc2lvbiBJRHMgdG8gc2NvcmVzXG4gKiBAcmV0dXJucyBJRCBvZiB0aGUgYmVzdCBtYXRjaGluZyBwZXJzb25hbGl0eSB0eXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTWF0Y2hpbmdQZXJzb25hbGl0eVR5cGUoZGltZW5zaW9uU2NvcmVzOiBSZWNvcmQ8bnVtYmVyLCBudW1iZXI+KTogbnVtYmVyIHtcbiAgLy8gUGVyc29uYWxpdHkgdHlwZSBtYXRjaGluZyBwcm9maWxlc1xuICAvLyBFYWNoIHByb2ZpbGUgZGVmaW5lcyB0aGUgZXhwZWN0ZWQgZGltZW5zaW9uIHNjb3JlcyBmb3IgYSBwZXJzb25hbGl0eSB0eXBlXG4gIGNvbnN0IHBlcnNvbmFsaXR5UHJvZmlsZXM6IFJlY29yZDxudW1iZXIsIFJlY29yZDxudW1iZXIsIG51bWJlcj4+ID0ge1xuICAgIC8vIERlbiBHbG9iYWxlIEFrdGl2aXN0ZW4gKFRoZSBHbG9iYWwgQWN0aXZpc3QpXG4gICAgMToge1xuICAgICAgMTogOCwgIC8vIEhpZ2ggb24gYWN0aXZpc21cbiAgICAgIDI6IDksICAvLyBIaWdoIG9uIHVuaXZlcnNhbCB2YWx1ZXNcbiAgICAgIDM6IDUsICAvLyBNb2RlcmF0ZSBvbiBpbmRpdmlkdWFsIGxpYmVydHlcbiAgICAgIDQ6IC03LCAvLyBMb3cgb24gc292ZXJlaWdudHkgKGZhdm9ycyBpbnRlcm5hdGlvbmFsIGludGVydmVudGlvbilcbiAgICAgIDU6IDYsICAvLyBNb2RlcmF0ZWx5IGhpZ2ggb24gZXF1YWxpdHlcbiAgICAgIDY6IC0zLCAvLyBTbGlnaHRseSBsb3cgb24gc2VjdXJpdHkgKGZhdm9ycyBwcml2YWN5KVxuICAgICAgNzogNCwgIC8vIE1vZGVyYXRlIG9uIGVtcGF0aHlcbiAgICAgIDg6IDcsICAvLyBIaWdoIG9uIGVjb25vbWljIGp1c3RpY2VcbiAgICAgIDk6IDgsICAvLyBIaWdoIG9uIGh1bWFuaXR5XG4gICAgICAxMDogMCAgLy8gTmV1dHJhbCBvbiByZWZvcm0gdnMgc3lzdGVtIGNoYW5nZVxuICAgIH0sXG4gICAgXG4gICAgLy8gRGVuIE1lZGbDuGxlbmRlIEZvcnN2YXJlcmVuIChUaGUgQ29tcGFzc2lvbmF0ZSBEZWZlbmRlcilcbiAgICAyOiB7XG4gICAgICAxOiAzLCAgLy8gTW9kZXJhdGUgb24gYWN0aXZpc21cbiAgICAgIDI6IDYsICAvLyBNb2RlcmF0ZWx5IGhpZ2ggb24gdW5pdmVyc2FsIHZhbHVlc1xuICAgICAgMzogMiwgIC8vIFNsaWdodGx5IHBvc2l0aXZlIG9uIGluZGl2aWR1YWwgbGliZXJ0eVxuICAgICAgNDogLTIsIC8vIFNsaWdodGx5IGxvdyBvbiBzb3ZlcmVpZ250eVxuICAgICAgNTogNSwgIC8vIE1vZGVyYXRlbHkgaGlnaCBvbiBlcXVhbGl0eVxuICAgICAgNjogLTEsIC8vIFNsaWdodGx5IGxvdyBvbiBzZWN1cml0eVxuICAgICAgNzogOSwgIC8vIFZlcnkgaGlnaCBvbiBlbXBhdGh5XG4gICAgICA4OiA0LCAgLy8gTW9kZXJhdGUgb24gZWNvbm9taWMganVzdGljZVxuICAgICAgOTogOSwgIC8vIFZlcnkgaGlnaCBvbiBodW1hbml0eVxuICAgICAgMTA6IDMgIC8vIE1vZGVyYXRlIG9uIHJlZm9ybVxuICAgIH0sXG4gICAgXG4gICAgLy8gRnJpaGV0c2ZvcmtqZW1wZXJlbiAoVGhlIExpYmVydHkgQWR2b2NhdGUpXG4gICAgMzoge1xuICAgICAgMTogNSwgIC8vIE1vZGVyYXRlbHkgaGlnaCBvbiBhY3RpdmlzbVxuICAgICAgMjogMywgIC8vIE1vZGVyYXRlIG9uIHVuaXZlcnNhbCB2YWx1ZXNcbiAgICAgIDM6IDEwLCAvLyBWZXJ5IGhpZ2ggb24gaW5kaXZpZHVhbCBsaWJlcnR5XG4gICAgICA0OiAyLCAgLy8gU2xpZ2h0bHkgaGlnaCBvbiBzb3ZlcmVpZ250eVxuICAgICAgNTogLTUsIC8vIExvdyBvbiBlcXVhbGl0eSAoZmF2b3JzIGxpYmVydHkpXG4gICAgICA2OiAtOSwgLy8gVmVyeSBsb3cgb24gc2VjdXJpdHkgKHN0cm9uZ2x5IGZhdm9ycyBwcml2YWN5KVxuICAgICAgNzogMCwgIC8vIE5ldXRyYWwgb24gZW1wYXRoeSB2cyBwcmluY2lwbGVzXG4gICAgICA4OiAtNywgLy8gTG93IG9uIGVjb25vbWljIGp1c3RpY2UgKGZhdm9ycyBtYXJrZXQgZnJlZWRvbSlcbiAgICAgIDk6IDMsICAvLyBNb2RlcmF0ZSBvbiBodW1hbml0eVxuICAgICAgMTA6IDAgIC8vIE5ldXRyYWwgb24gcmVmb3JtIHZzIHN5c3RlbSBjaGFuZ2VcbiAgICB9LFxuICAgIFxuICAgIC8vIExpa2VzdGlsbGluZ3Nmb3JramVtcGVyZW4gKFRoZSBFcXVhbGl0eSBDaGFtcGlvbilcbiAgICA0OiB7XG4gICAgICAxOiA2LCAgLy8gTW9kZXJhdGVseSBoaWdoIG9uIGFjdGl2aXNtXG4gICAgICAyOiA3LCAgLy8gSGlnaCBvbiB1bml2ZXJzYWwgdmFsdWVzXG4gICAgICAzOiAwLCAgLy8gTmV1dHJhbCBvbiBpbmRpdmlkdWFsIGxpYmVydHkgdnMgY29sbGVjdGl2ZSByZXNwb25zaWJpbGl0eVxuICAgICAgNDogLTMsIC8vIE1vZGVyYXRlbHkgbG93IG9uIHNvdmVyZWlnbnR5XG4gICAgICA1OiAxMCwgLy8gVmVyeSBoaWdoIG9uIGVxdWFsaXR5XG4gICAgICA2OiAwLCAgLy8gTmV1dHJhbCBvbiBzZWN1cml0eSB2cyBwcml2YWN5XG4gICAgICA3OiA1LCAgLy8gTW9kZXJhdGVseSBoaWdoIG9uIGVtcGF0aHlcbiAgICAgIDg6IDgsICAvLyBIaWdoIG9uIGVjb25vbWljIGp1c3RpY2VcbiAgICAgIDk6IDYsICAvLyBNb2RlcmF0ZWx5IGhpZ2ggb24gaHVtYW5pdHlcbiAgICAgIDEwOiA0ICAvLyBNb2RlcmF0ZSBvbiByZWZvcm1cbiAgICB9LFxuICAgIFxuICAgIC8vIERlbiBQcmFnbWF0aXNrZSBSZWZvcm1hdG9yZW4gKFRoZSBQcmFnbWF0aWMgUmVmb3JtZXIpXG4gICAgNToge1xuICAgICAgMTogLTYsIC8vIExvdyBvbiBhY3RpdmlzbSAoZmF2b3JzIGdyYWR1YWwgY2hhbmdlKVxuICAgICAgMjogMiwgIC8vIFNsaWdodGx5IHBvc2l0aXZlIG9uIHVuaXZlcnNhbCB2YWx1ZXNcbiAgICAgIDM6IDAsICAvLyBOZXV0cmFsIG9uIGluZGl2aWR1YWwgbGliZXJ0eSB2cyBjb2xsZWN0aXZlIHJlc3BvbnNpYmlsaXR5XG4gICAgICA0OiAzLCAgLy8gTW9kZXJhdGUgb24gc292ZXJlaWdudHlcbiAgICAgIDU6IDIsICAvLyBTbGlnaHRseSBwb3NpdGl2ZSBvbiBlcXVhbGl0eVxuICAgICAgNjogMywgIC8vIE1vZGVyYXRlIG9uIHNlY3VyaXR5XG4gICAgICA3OiAtMiwgLy8gU2xpZ2h0bHkgbG93IG9uIGVtcGF0aHkgKGZhdm9ycyBwcmluY2lwbGVzKVxuICAgICAgODogMCwgIC8vIE5ldXRyYWwgb24gZWNvbm9taWMganVzdGljZSB2cyBtYXJrZXQgZnJlZWRvbVxuICAgICAgOTogLTUsIC8vIExvdyBvbiBodW1hbml0eSAoZmF2b3JzIHByYWdtYXRpc20pXG4gICAgICAxMDogOSAgLy8gVmVyeSBoaWdoIG9uIHJlZm9ybVxuICAgIH0sXG4gICAgXG4gICAgLy8gVHJhZGlzam9uc3Zva3RlcmVuIChUaGUgVHJhZGl0aW9uIEd1YXJkaWFuKVxuICAgIDY6IHtcbiAgICAgIDE6IC04LCAvLyBWZXJ5IGxvdyBvbiBhY3RpdmlzbSAoc3Ryb25nbHkgZmF2b3JzIGdyYWR1YWwgY2hhbmdlKVxuICAgICAgMjogLTksIC8vIFZlcnkgbG93IG9uIHVuaXZlcnNhbCB2YWx1ZXMgKHN0cm9uZ2x5IGZhdm9ycyBjdWx0dXJhbCByZWxhdGl2aXNtKVxuICAgICAgMzogLTMsIC8vIE1vZGVyYXRlbHkgbG93IG9uIGluZGl2aWR1YWwgbGliZXJ0eSAoZmF2b3JzIGNvbGxlY3RpdmUgcmVzcG9uc2liaWxpdHkpXG4gICAgICA0OiA5LCAgLy8gVmVyeSBoaWdoIG9uIHNvdmVyZWlnbnR5XG4gICAgICA1OiAtNCwgLy8gTW9kZXJhdGVseSBsb3cgb24gZXF1YWxpdHkgKGZhdm9ycyBsaWJlcnR5KVxuICAgICAgNjogNywgIC8vIEhpZ2ggb24gc2VjdXJpdHlcbiAgICAgIDc6IC0zLCAvLyBNb2RlcmF0ZWx5IGxvdyBvbiBlbXBhdGh5IChmYXZvcnMgcHJpbmNpcGxlcylcbiAgICAgIDg6IC01LCAvLyBMb3cgb24gZWNvbm9taWMganVzdGljZSAoZmF2b3JzIG1hcmtldCBmcmVlZG9tKVxuICAgICAgOTogLTIsIC8vIFNsaWdodGx5IGxvdyBvbiBodW1hbml0eSAoZmF2b3JzIHByYWdtYXRpc20pXG4gICAgICAxMDogMiAgLy8gU2xpZ2h0bHkgcG9zaXRpdmUgb24gcmVmb3JtXG4gICAgfSxcbiAgICBcbiAgICAvLyBTeXN0ZW1rcml0aWtlcmVuIChUaGUgU3lzdGVtIENyaXRpYylcbiAgICA3OiB7XG4gICAgICAxOiA3LCAgLy8gSGlnaCBvbiBhY3RpdmlzbVxuICAgICAgMjogNCwgIC8vIE1vZGVyYXRlIG9uIHVuaXZlcnNhbCB2YWx1ZXNcbiAgICAgIDM6IC0yLCAvLyBTbGlnaHRseSBsb3cgb24gaW5kaXZpZHVhbCBsaWJlcnR5IChmYXZvcnMgY29sbGVjdGl2ZSByZXNwb25zaWJpbGl0eSlcbiAgICAgIDQ6IDAsICAvLyBOZXV0cmFsIG9uIHNvdmVyZWlnbnR5XG4gICAgICA1OiA4LCAgLy8gSGlnaCBvbiBlcXVhbGl0eVxuICAgICAgNjogLTQsIC8vIE1vZGVyYXRlbHkgbG93IG9uIHNlY3VyaXR5IChmYXZvcnMgcHJpdmFjeSlcbiAgICAgIDc6IDMsICAvLyBNb2RlcmF0ZSBvbiBlbXBhdGh5XG4gICAgICA4OiAxMCwgLy8gVmVyeSBoaWdoIG9uIGVjb25vbWljIGp1c3RpY2VcbiAgICAgIDk6IDUsICAvLyBNb2RlcmF0ZWx5IGhpZ2ggb24gaHVtYW5pdHlcbiAgICAgIDEwOiAtOSAvLyBWZXJ5IGxvdyBvbiByZWZvcm0gKHN0cm9uZ2x5IGZhdm9ycyBzeXN0ZW0gY2hhbmdlKVxuICAgIH0sXG4gICAgXG4gICAgLy8gUmV0dHN0YXRzZm9ya2plbXBlcmVuIChUaGUgUnVsZSBvZiBMYXcgQWR2b2NhdGUpXG4gICAgODoge1xuICAgICAgMTogLTcsIC8vIExvdyBvbiBhY3RpdmlzbSAoZmF2b3JzIGdyYWR1YWwgY2hhbmdlKVxuICAgICAgMjogNSwgIC8vIE1vZGVyYXRlbHkgaGlnaCBvbiB1bml2ZXJzYWwgdmFsdWVzXG4gICAgICAzOiAzLCAgLy8gTW9kZXJhdGUgb24gaW5kaXZpZHVhbCBsaWJlcnR5XG4gICAgICA0OiA0LCAgLy8gTW9kZXJhdGUgb24gc292ZXJlaWdudHlcbiAgICAgIDU6IDYsICAvLyBNb2RlcmF0ZWx5IGhpZ2ggb24gZXF1YWxpdHlcbiAgICAgIDY6IDUsICAvLyBNb2RlcmF0ZWx5IGhpZ2ggb24gc2VjdXJpdHlcbiAgICAgIDc6IC01LCAvLyBMb3cgb24gZW1wYXRoeSAoZmF2b3JzIHByaW5jaXBsZXMpXG4gICAgICA4OiAyLCAgLy8gU2xpZ2h0bHkgcG9zaXRpdmUgb24gZWNvbm9taWMganVzdGljZVxuICAgICAgOTogMCwgIC8vIE5ldXRyYWwgb24gaHVtYW5pdHkgdnMgcHJhZ21hdGlzbVxuICAgICAgMTA6IDggIC8vIEhpZ2ggb24gcmVmb3JtXG4gICAgfSxcbiAgICBcbiAgICAvLyBNaWxqw7hyZXR0aWdoZXRzYWt0aXZpc3RlbiAoVGhlIEVudmlyb25tZW50YWwgUmlnaHRzIEFjdGl2aXN0KVxuICAgIDk6IHtcbiAgICAgIDE6IDgsICAvLyBIaWdoIG9uIGFjdGl2aXNtXG4gICAgICAyOiA2LCAgLy8gTW9kZXJhdGVseSBoaWdoIG9uIHVuaXZlcnNhbCB2YWx1ZXNcbiAgICAgIDM6IC00LCAvLyBNb2RlcmF0ZWx5IGxvdyBvbiBpbmRpdmlkdWFsIGxpYmVydHkgKGZhdm9ycyBjb2xsZWN0aXZlIHJlc3BvbnNpYmlsaXR5KVxuICAgICAgNDogLTIsIC8vIFNsaWdodGx5IGxvdyBvbiBzb3ZlcmVpZ250eVxuICAgICAgNTogNSwgIC8vIE1vZGVyYXRlbHkgaGlnaCBvbiBlcXVhbGl0eVxuICAgICAgNjogMCwgIC8vIE5ldXRyYWwgb24gc2VjdXJpdHkgdnMgcHJpdmFjeVxuICAgICAgNzogNywgIC8vIEhpZ2ggb24gZW1wYXRoeVxuICAgICAgODogNiwgIC8vIE1vZGVyYXRlbHkgaGlnaCBvbiBlY29ub21pYyBqdXN0aWNlXG4gICAgICA5OiA4LCAgLy8gSGlnaCBvbiBodW1hbml0eVxuICAgICAgMTA6IC02IC8vIExvdyBvbiByZWZvcm0gKGZhdm9ycyBzeXN0ZW0gY2hhbmdlKVxuICAgIH1cbiAgfTtcblxuICAvLyBDYWxjdWxhdGUgc2ltaWxhcml0eSBzY29yZXMgZm9yIGVhY2ggcGVyc29uYWxpdHkgdHlwZVxuICBjb25zdCBzaW1pbGFyaXR5U2NvcmVzOiBSZWNvcmQ8bnVtYmVyLCBudW1iZXI+ID0ge307XG4gIFxuICBPYmplY3QuZW50cmllcyhwZXJzb25hbGl0eVByb2ZpbGVzKS5mb3JFYWNoKChbdHlwZUlkLCBwcm9maWxlXSkgPT4ge1xuICAgIGxldCBzaW1pbGFyaXR5ID0gMDtcbiAgICBsZXQgd2VpZ2h0c1N1bSA9IDA7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIHdlaWdodGVkIEV1Y2xpZGVhbiBkaXN0YW5jZSAobG93ZXIgaXMgYmV0dGVyKVxuICAgIE9iamVjdC5lbnRyaWVzKHByb2ZpbGUpLmZvckVhY2goKFtkaW1lbnNpb25JZCwgZXhwZWN0ZWRTY29yZV0pID0+IHtcbiAgICAgIGNvbnN0IGRpbUlkID0gTnVtYmVyKGRpbWVuc2lvbklkKTtcbiAgICAgIGNvbnN0IHVzZXJTY29yZSA9IGRpbWVuc2lvblNjb3Jlc1tkaW1JZF0gfHwgMDtcbiAgICAgIGNvbnN0IGRpZmZlcmVuY2UgPSB1c2VyU2NvcmUgLSBleHBlY3RlZFNjb3JlO1xuICAgICAgXG4gICAgICAvLyBHaXZlIG1vcmUgd2VpZ2h0IHRvIGV4dHJlbWUgZXhwZWN0ZWQgc2NvcmVzICh2YWx1ZXMgbmVhciAtMTAgb3IgMTApXG4gICAgICAvLyBUaGVzZSBhcmUgbW9yZSBkZWZpbmluZyBjaGFyYWN0ZXJpc3RpY3Mgb2YgcGVyc29uYWxpdHkgdHlwZXNcbiAgICAgIGNvbnN0IHdlaWdodCA9IE1hdGguYWJzKGV4cGVjdGVkU2NvcmUpIC8gNTtcbiAgICAgIHdlaWdodHNTdW0gKz0gd2VpZ2h0O1xuICAgICAgXG4gICAgICBzaW1pbGFyaXR5IC09IChkaWZmZXJlbmNlICogZGlmZmVyZW5jZSAqIHdlaWdodCk7IC8vIE5lZ2F0aXZlIHdlaWdodGVkIHNxdWFyZWQgZGlmZmVyZW5jZVxuICAgIH0pO1xuICAgIFxuICAgIC8vIE5vcm1hbGl6ZSBieSBzdW0gb2Ygd2VpZ2h0cyB0byBtYWtlIGNvbXBhcmlzb24gZmFpclxuICAgIGlmICh3ZWlnaHRzU3VtID4gMCkge1xuICAgICAgc2ltaWxhcml0eSA9IHNpbWlsYXJpdHkgLyB3ZWlnaHRzU3VtO1xuICAgIH1cbiAgICBcbiAgICAvLyBBZGQgYSBzbWFsbCByYW5kb20gZmFjdG9yIHRvIGJyZWFrIHRpZXMgYW5kIGVuY291cmFnZSB2YXJpZXR5XG4gICAgLy8gVGhlIGZhY3RvciBpcyBzbWFsbCBlbm91Z2ggdGhhdCBpdCB3b24ndCBvdmVycmlkZSBjbGVhciBtYXRjaGVzLFxuICAgIC8vIGJ1dCB3aWxsIGhlbHAgZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIGNsb3NlIG1hdGNoZXNcbiAgICBjb25zdCByYW5kb21GYWN0b3IgPSBNYXRoLnJhbmRvbSgpICogMC41O1xuICAgIHNpbWlsYXJpdHkgKz0gcmFuZG9tRmFjdG9yO1xuICAgIFxuICAgIHNpbWlsYXJpdHlTY29yZXNbTnVtYmVyKHR5cGVJZCldID0gc2ltaWxhcml0eTtcbiAgfSk7XG4gIFxuICAvLyBGaW5kIHBlcnNvbmFsaXR5IHR5cGUgd2l0aCBoaWdoZXN0IHNpbWlsYXJpdHkgc2NvcmVcbiAgbGV0IGJlc3RNYXRjaFR5cGVJZCA9IDE7XG4gIGxldCBoaWdoZXN0U2ltaWxhcml0eSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgXG4gIE9iamVjdC5lbnRyaWVzKHNpbWlsYXJpdHlTY29yZXMpLmZvckVhY2goKFt0eXBlSWQsIHNjb3JlXSkgPT4ge1xuICAgIGlmIChzY29yZSA+IGhpZ2hlc3RTaW1pbGFyaXR5KSB7XG4gICAgICBoaWdoZXN0U2ltaWxhcml0eSA9IHNjb3JlO1xuICAgICAgYmVzdE1hdGNoVHlwZUlkID0gTnVtYmVyKHR5cGVJZCk7XG4gICAgfVxuICB9KTtcbiAgXG4gIHJldHVybiBiZXN0TWF0Y2hUeXBlSWQ7XG59XG5cbi8qKlxuICogRmluZCByZWNvbW1lbmRlZCBBbW5lc3R5IGNhdXNlcyBiYXNlZCBvbiBwZXJzb25hbGl0eSB0eXBlXG4gKiBAcGFyYW0gcGVyc29uYWxpdHlUeXBlSWQgSUQgb2YgdGhlIG1hdGNoZWQgcGVyc29uYWxpdHkgdHlwZVxuICogQHJldHVybnMgQXJyYXkgb2YgcmVjb21tZW5kZWQgY2F1c2UgSURzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kUmVjb21tZW5kZWRDYXVzZXMocGVyc29uYWxpdHlUeXBlSWQ6IG51bWJlcik6IG51bWJlcltdIHtcbiAgLy8gTWFwcGluZyBvZiBwZXJzb25hbGl0eSB0eXBlcyB0byByZWNvbW1lbmRlZCBjYXVzZXNcbiAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdvdWxkIGNvbWUgZnJvbSB0aGUgZGF0YWJhc2VcbiAgY29uc3QgcmVjb21tZW5kYXRpb25NYXA6IFJlY29yZDxudW1iZXIsIG51bWJlcltdPiA9IHtcbiAgICAxOiBbMSwgNCwgOF0sICAgIC8vIEdsb2JhbCBBY3RpdmlzdDogUmVmdWdlZSBSaWdodHMsIERlYXRoIFBlbmFsdHkgQWJvbGl0aW9uLCBQcm90ZWN0aW9uIGluIENvbmZsaWN0IFpvbmVzXG4gICAgMjogWzEsIDksIDZdLCAgICAvLyBDb21wYXNzaW9uYXRlIERlZmVuZGVyOiBSZWZ1Z2VlIFJpZ2h0cywgV29tZW4ncyBSaWdodHMsIExHQlRRKyBSaWdodHNcbiAgICAzOiBbMiwgNywgNF0sICAgIC8vIExpYmVydHkgQWR2b2NhdGU6IEZyZWVkb20gb2YgRXhwcmVzc2lvbiwgUHJpdmFjeSBhbmQgU3VydmVpbGxhbmNlLCBEZWF0aCBQZW5hbHR5IEFib2xpdGlvblxuICAgIDQ6IFs2LCA5LCA1XSwgICAgLy8gRXF1YWxpdHkgQ2hhbXBpb246IExHQlRRKyBSaWdodHMsIFdvbWVuJ3MgUmlnaHRzLCBGcmVlZG9tIG9mIEFzc2VtYmx5XG4gICAgNTogWzMsIDgsIDJdLCAgICAvLyBQcmFnbWF0aWMgUmVmb3JtZXI6IENvcnBvcmF0ZSBBY2NvdW50YWJpbGl0eSwgUHJvdGVjdGlvbiBpbiBDb25mbGljdCBab25lcywgRnJlZWRvbSBvZiBFeHByZXNzaW9uXG4gICAgNjogWzEwLCAyLCAzXSwgICAvLyBUcmFkaXRpb24gR3VhcmRpYW46IEluZGlnZW5vdXMgUmlnaHRzLCBGcmVlZG9tIG9mIEV4cHJlc3Npb24sIENvcnBvcmF0ZSBBY2NvdW50YWJpbGl0eVxuICAgIDc6IFszLCA1LCA4XSwgICAgLy8gU3lzdGVtIENyaXRpYzogQ29ycG9yYXRlIEFjY291bnRhYmlsaXR5LCBGcmVlZG9tIG9mIEFzc2VtYmx5LCBQcm90ZWN0aW9uIGluIENvbmZsaWN0IFpvbmVzXG4gICAgODogWzQsIDIsIDddLCAgICAvLyBSdWxlIG9mIExhdyBBZHZvY2F0ZTogRGVhdGggUGVuYWx0eSBBYm9saXRpb24sIEZyZWVkb20gb2YgRXhwcmVzc2lvbiwgUHJpdmFjeSBhbmQgU3VydmVpbGxhbmNlXG4gICAgOTogWzEwLCAzLCA4XSAgICAvLyBFbnZpcm9ubWVudGFsIFJpZ2h0cyBBY3RpdmlzdDogSW5kaWdlbm91cyBSaWdodHMsIENvcnBvcmF0ZSBBY2NvdW50YWJpbGl0eSwgUHJvdGVjdGlvbiBpbiBDb25mbGljdCBab25lc1xuICB9O1xuICBcbiAgcmV0dXJuIHJlY29tbWVuZGF0aW9uTWFwW3BlcnNvbmFsaXR5VHlwZUlkXSB8fCBbMSwgMiwgM107IC8vIERlZmF1bHQgcmVjb21tZW5kYXRpb25zIGlmIG5vIG1hdGNoXG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBjb21wbGV0ZSB1c2VyIHJlc3VsdCBiYXNlZCBvbiByZXNwb25zZXNcbiAqIEBwYXJhbSByZXNwb25zZXMgQXJyYXkgb2YgdXNlciByZXNwb25zZXNcbiAqIEByZXR1cm5zIENvbXBsZXRlIHVzZXIgcmVzdWx0IHdpdGggcGVyc29uYWxpdHkgdHlwZSwgZGltZW5zaW9uIHNjb3JlcywgYW5kIHJlY29tbWVuZGVkIGNhdXNlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVVc2VyUmVzdWx0KHJlc3BvbnNlczogVXNlclJlc3BvbnNlW10sIHNlc3Npb25JZDogc3RyaW5nKTogVXNlclJlc3VsdCB7XG4gIC8vIENhbGN1bGF0ZSBkaW1lbnNpb24gc2NvcmVzXG4gIGNvbnN0IGRpbWVuc2lvblNjb3JlcyA9IGNhbGN1bGF0ZURpbWVuc2lvblNjb3JlcyhyZXNwb25zZXMpO1xuICBcbiAgLy8gRmluZCBtYXRjaGluZyBwZXJzb25hbGl0eSB0eXBlXG4gIGNvbnN0IHBlcnNvbmFsaXR5VHlwZUlkID0gZmluZE1hdGNoaW5nUGVyc29uYWxpdHlUeXBlKGRpbWVuc2lvblNjb3Jlcyk7XG4gIFxuICAvLyBGaW5kIHJlY29tbWVuZGVkIGNhdXNlc1xuICBjb25zdCByZWNvbW1lbmRlZENhdXNlcyA9IGZpbmRSZWNvbW1lbmRlZENhdXNlcyhwZXJzb25hbGl0eVR5cGVJZCk7XG4gIFxuICByZXR1cm4ge1xuICAgIHNlc3Npb25JZCxcbiAgICBwZXJzb25hbGl0eVR5cGVJZCxcbiAgICBkaW1lbnNpb25TY29yZXMsXG4gICAgcmVjb21tZW5kZWRDYXVzZXNcbiAgfTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhbiBlbmhhbmNlZCB1c2VyIHJlc3VsdCB3aXRoIGFsbCByZWxhdGVkIGRhdGEgZm9yIGRpc3BsYXlcbiAqIEBwYXJhbSByZXNwb25zZXMgQXJyYXkgb2YgdXNlciByZXNwb25zZXNcbiAqIEBwYXJhbSBzZXNzaW9uSWQgU2Vzc2lvbiBpZGVudGlmaWVyXG4gKiBAcmV0dXJucyBFbmhhbmNlZCB1c2VyIHJlc3VsdCB3aXRoIGZ1bGwgZGV0YWlscyBmb3IgVUkgZGlzcGxheVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVFbmhhbmNlZFVzZXJSZXN1bHQocmVzcG9uc2VzOiBVc2VyUmVzcG9uc2VbXSwgc2Vzc2lvbklkOiBzdHJpbmcpOiBFbmhhbmNlZFVzZXJSZXN1bHQge1xuICAvLyBHZW5lcmF0ZSB0aGUgYmFzaWMgdXNlciByZXN1bHRcbiAgY29uc3QgdXNlclJlc3VsdCA9IGdlbmVyYXRlVXNlclJlc3VsdChyZXNwb25zZXMsIHNlc3Npb25JZCk7XG4gIFxuICAvLyBHZXQgdGhlIHBlcnNvbmFsaXR5IHR5cGVcbiAgY29uc3QgcGVyc29uYWxpdHlUeXBlID0gcGVyc29uYWxpdHlUeXBlcy5maW5kKHAgPT4gcC5pZCA9PT0gdXNlclJlc3VsdC5wZXJzb25hbGl0eVR5cGVJZCk7XG4gIFxuICAvLyBGb3JtYXQgZGltZW5zaW9uIGRldGFpbHMgYW5kIHNvcnQgYnkgYWJzb2x1dGUgc2NvcmUgKGhpZ2hlc3QgZmlyc3QpXG4gIGNvbnN0IGRpbWVuc2lvbkRldGFpbHMgPSBPYmplY3QuZW50cmllcyh1c2VyUmVzdWx0LmRpbWVuc2lvblNjb3JlcylcbiAgICAubWFwKChbZGltSWQsIHNjb3JlXSkgPT4ge1xuICAgICAgY29uc3QgZGltZW5zaW9uID0gZGltZW5zaW9ucy5maW5kKGQgPT4gZC5pZCA9PT0gTnVtYmVyKGRpbUlkKSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaW1lbnNpb24sXG4gICAgICAgIHNjb3JlLFxuICAgICAgICBkZXNjcmlwdGlvbjogc2NvcmUgPiAwID8gZGltZW5zaW9uPy5oaWdoRGVzY3JpcHRpb24gOiBkaW1lbnNpb24/Lmxvd0Rlc2NyaXB0aW9uXG4gICAgICB9O1xuICAgIH0pXG4gICAgLnNvcnQoKGEsIGIpID0+IE1hdGguYWJzKGIuc2NvcmUpIC0gTWF0aC5hYnMoYS5zY29yZSkpO1xuICBcbiAgLy8gR2V0IHRoZSByZWNvbW1lbmRlZCBjYXVzZXNcbiAgY29uc3QgY2F1c2VzID0gdXNlclJlc3VsdC5yZWNvbW1lbmRlZENhdXNlcy5tYXAoY2F1c2VJZCA9PiBcbiAgICBhbW5lc3R5Q2F1c2VzLmZpbmQoYyA9PiBjLmlkID09PSBjYXVzZUlkKVxuICApO1xuICBcbiAgcmV0dXJuIHtcbiAgICB1c2VyUmVzdWx0LFxuICAgIHBlcnNvbmFsaXR5VHlwZSxcbiAgICBkaW1lbnNpb25EZXRhaWxzLFxuICAgIGNhdXNlc1xuICB9O1xufVxuIl0sIm5hbWVzIjpbInF1ZXN0aW9uRGltZW5zaW9uTWFwcGluZ3MiLCJwZXJzb25hbGl0eVR5cGVzIiwiZGltZW5zaW9ucyIsImFtbmVzdHlDYXVzZXMiLCJjYWxjdWxhdGVEaW1lbnNpb25TY29yZXMiLCJyZXNwb25zZXMiLCJkaW1lbnNpb25TY29yZXMiLCJkaW1lbnNpb25Db3VudHMiLCJmb3JFYWNoIiwiZGltZW5zaW9uIiwiaWQiLCJyZXNwb25zZSIsIm1hcHBpbmdzIiwiZmlsdGVyIiwibWFwcGluZyIsInF1ZXN0aW9uSWQiLCJzY29yZUNoYW5nZSIsImFncmVlIiwid2VpZ2h0IiwiZGltZW5zaW9uSWQiLCJkaW1JZCIsInJhd1Njb3JlIiwicXVlc3Rpb25Db3VudCIsImF2Z1Njb3JlUGVyUXVlc3Rpb24iLCJNYXRoIiwibWF4IiwibWluIiwicmFuZG9tVmFyaWF0aW9uIiwicmFuZG9tIiwiZmluZE1hdGNoaW5nUGVyc29uYWxpdHlUeXBlIiwicGVyc29uYWxpdHlQcm9maWxlcyIsInNpbWlsYXJpdHlTY29yZXMiLCJPYmplY3QiLCJlbnRyaWVzIiwidHlwZUlkIiwicHJvZmlsZSIsInNpbWlsYXJpdHkiLCJ3ZWlnaHRzU3VtIiwiZXhwZWN0ZWRTY29yZSIsIk51bWJlciIsInVzZXJTY29yZSIsImRpZmZlcmVuY2UiLCJhYnMiLCJyYW5kb21GYWN0b3IiLCJiZXN0TWF0Y2hUeXBlSWQiLCJoaWdoZXN0U2ltaWxhcml0eSIsIk5FR0FUSVZFX0lORklOSVRZIiwic2NvcmUiLCJmaW5kUmVjb21tZW5kZWRDYXVzZXMiLCJwZXJzb25hbGl0eVR5cGVJZCIsInJlY29tbWVuZGF0aW9uTWFwIiwiZ2VuZXJhdGVVc2VyUmVzdWx0Iiwic2Vzc2lvbklkIiwicmVjb21tZW5kZWRDYXVzZXMiLCJnZW5lcmF0ZUVuaGFuY2VkVXNlclJlc3VsdCIsInVzZXJSZXN1bHQiLCJwZXJzb25hbGl0eVR5cGUiLCJmaW5kIiwicCIsImRpbWVuc2lvbkRldGFpbHMiLCJtYXAiLCJkIiwiZGVzY3JpcHRpb24iLCJoaWdoRGVzY3JpcHRpb24iLCJsb3dEZXNjcmlwdGlvbiIsInNvcnQiLCJhIiwiYiIsImNhdXNlcyIsImNhdXNlSWQiLCJjIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/data/personalityMatching.ts\n"));

/***/ })

});