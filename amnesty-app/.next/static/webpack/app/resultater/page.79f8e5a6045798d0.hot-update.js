"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/resultater/page",{

/***/ "(app-pages-browser)/./src/lib/data/personalityMatching.ts":
/*!*********************************************!*\
  !*** ./src/lib/data/personalityMatching.ts ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateDimensionScores: () => (/* binding */ calculateDimensionScores),\n/* harmony export */   findMatchingPersonalityType: () => (/* binding */ findMatchingPersonalityType),\n/* harmony export */   findRecommendedCauses: () => (/* binding */ findRecommendedCauses),\n/* harmony export */   generateEnhancedUserResult: () => (/* binding */ generateEnhancedUserResult),\n/* harmony export */   generateUserResult: () => (/* binding */ generateUserResult)\n/* harmony export */ });\n/* harmony import */ var _questionDimensionMappings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./questionDimensionMappings */ \"(app-pages-browser)/./src/lib/data/questionDimensionMappings.ts\");\n/* harmony import */ var _personalityTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./personalityTypes */ \"(app-pages-browser)/./src/lib/data/personalityTypes.ts\");\n/* harmony import */ var _dimensions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dimensions */ \"(app-pages-browser)/./src/lib/data/dimensions.ts\");\n/* harmony import */ var _amnestyCauses__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./amnestyCauses */ \"(app-pages-browser)/./src/lib/data/amnestyCauses.ts\");\n// Personality matching algorithm for Amnesty International Interactive Experience\n\n\n\n\n/**\n * Calculate dimension scores based on user responses\n * @param responses Array of user responses (agree/disagree)\n * @returns Object mapping dimension IDs to scores\n */ function calculateDimensionScores(responses) {\n    // Initialize scores for all dimensions to 0\n    const dimensionScores = {};\n    const dimensionCounts = {};\n    _dimensions__WEBPACK_IMPORTED_MODULE_2__.dimensions.forEach((dimension)=>{\n        dimensionScores[dimension.id] = 0;\n        dimensionCounts[dimension.id] = 0;\n    });\n    // Process each response\n    responses.forEach((response)=>{\n        // Find all dimension mappings for this question\n        const mappings = _questionDimensionMappings__WEBPACK_IMPORTED_MODULE_0__.questionDimensionMappings.filter((mapping)=>mapping.questionId === response.questionId);\n        // Update scores based on response\n        mappings.forEach((mapping)=>{\n            // If user agrees, add the weight; if disagrees, subtract the weight\n            const scoreChange = response.agree ? mapping.weight : -mapping.weight;\n            dimensionScores[mapping.dimensionId] += scoreChange;\n            dimensionCounts[mapping.dimensionId]++; // Count how many questions affect each dimension\n        });\n    });\n    // Normalize scores to a scale of -10 to 10, but account for number of questions per dimension\n    _dimensions__WEBPACK_IMPORTED_MODULE_2__.dimensions.forEach((dimension)=>{\n        const dimId = dimension.id;\n        const rawScore = dimensionScores[dimId];\n        const questionCount = dimensionCounts[dimId];\n        if (questionCount > 0) {\n            // Normalize based on actual questions answered for this dimension\n            // This prevents dimensions with fewer questions from being under-represented\n            const avgScorePerQuestion = rawScore / questionCount;\n            // Scale to -10 to 10 range, with a factor to make scores more pronounced\n            // The 3 is based on our weight scale of -3 to 3\n            dimensionScores[dimId] = Math.max(-10, Math.min(10, avgScorePerQuestion * (10 / 3)));\n        } else {\n            // If no questions affected this dimension, leave it at 0\n            dimensionScores[dimId] = 0;\n        }\n    });\n    return dimensionScores;\n}\n/**\n * Determine the best matching personality type based on dimension scores\n * @param dimensionScores Object mapping dimension IDs to scores\n * @returns ID of the best matching personality type\n */ function findMatchingPersonalityType(dimensionScores) {\n    // Personality type matching profiles\n    // Each profile defines the expected dimension scores for a personality type\n    const personalityProfiles = {\n        // Den Globale Aktivisten (The Global Activist)\n        1: {\n            1: 8,\n            2: 9,\n            3: 5,\n            4: -7,\n            5: 6,\n            6: -3,\n            7: 4,\n            8: 7,\n            9: 8,\n            10: 0 // Neutral on reform vs system change\n        },\n        // Den Medfølende Forsvareren (The Compassionate Defender)\n        2: {\n            1: 3,\n            2: 6,\n            3: 2,\n            4: -2,\n            5: 5,\n            6: -1,\n            7: 9,\n            8: 4,\n            9: 9,\n            10: 3 // Moderate on reform\n        },\n        // Frihetsforkjemperen (The Liberty Advocate)\n        3: {\n            1: 5,\n            2: 3,\n            3: 10,\n            4: 2,\n            5: -5,\n            6: -9,\n            7: 0,\n            8: -7,\n            9: 3,\n            10: 0 // Neutral on reform vs system change\n        },\n        // Likestillingsforkjemperen (The Equality Champion)\n        4: {\n            1: 6,\n            2: 7,\n            3: 0,\n            4: -3,\n            5: 10,\n            6: 0,\n            7: 5,\n            8: 8,\n            9: 6,\n            10: 4 // Moderate on reform\n        },\n        // Den Pragmatiske Reformatoren (The Pragmatic Reformer)\n        5: {\n            1: -6,\n            2: 2,\n            3: 0,\n            4: 3,\n            5: 2,\n            6: 3,\n            7: -2,\n            8: 0,\n            9: -5,\n            10: 9 // Very high on reform\n        },\n        // Tradisjonsvokteren (The Tradition Guardian)\n        6: {\n            1: -8,\n            2: -9,\n            3: -3,\n            4: 9,\n            5: -4,\n            6: 7,\n            7: -3,\n            8: -5,\n            9: -2,\n            10: 2 // Slightly positive on reform\n        },\n        // Systemkritikeren (The System Critic)\n        7: {\n            1: 7,\n            2: 4,\n            3: -2,\n            4: 0,\n            5: 8,\n            6: -4,\n            7: 3,\n            8: 10,\n            9: 5,\n            10: -9 // Very low on reform (strongly favors system change)\n        },\n        // Rettstatsforkjemperen (The Rule of Law Advocate)\n        8: {\n            1: -7,\n            2: 5,\n            3: 3,\n            4: 4,\n            5: 6,\n            6: 5,\n            7: -5,\n            8: 2,\n            9: 0,\n            10: 8 // High on reform\n        },\n        // Miljørettighetsaktivisten (The Environmental Rights Activist)\n        9: {\n            1: 8,\n            2: 6,\n            3: -4,\n            4: -2,\n            5: 5,\n            6: 0,\n            7: 7,\n            8: 6,\n            9: 8,\n            10: -6 // Low on reform (favors system change)\n        }\n    };\n    // Calculate similarity scores for each personality type\n    const similarityScores = {};\n    Object.entries(personalityProfiles).forEach((param)=>{\n        let [typeId, profile] = param;\n        let similarity = 0;\n        let weightsSum = 0;\n        // Calculate weighted Euclidean distance (lower is better)\n        Object.entries(profile).forEach((param)=>{\n            let [dimensionId, expectedScore] = param;\n            const dimId = Number(dimensionId);\n            const userScore = dimensionScores[dimId] || 0;\n            const difference = userScore - expectedScore;\n            // Give more weight to extreme expected scores (values near -10 or 10)\n            // These are more defining characteristics of personality types\n            const weight = Math.abs(expectedScore) / 5;\n            weightsSum += weight;\n            similarity -= difference * difference * weight; // Negative weighted squared difference\n        });\n        // Normalize by sum of weights to make comparison fair\n        if (weightsSum > 0) {\n            similarity = similarity / weightsSum;\n        }\n        similarityScores[Number(typeId)] = similarity;\n    });\n    // Find personality type with highest similarity score\n    let bestMatchTypeId = 1;\n    let highestSimilarity = Number.NEGATIVE_INFINITY;\n    Object.entries(similarityScores).forEach((param)=>{\n        let [typeId, score] = param;\n        if (score > highestSimilarity) {\n            highestSimilarity = score;\n            bestMatchTypeId = Number(typeId);\n        }\n    });\n    return bestMatchTypeId;\n}\n/**\n * Find recommended Amnesty causes based on personality type\n * @param personalityTypeId ID of the matched personality type\n * @returns Array of recommended cause IDs\n */ function findRecommendedCauses(personalityTypeId) {\n    // Mapping of personality types to recommended causes\n    // In a real implementation, this would come from the database\n    const recommendationMap = {\n        1: [\n            1,\n            4,\n            8\n        ],\n        2: [\n            1,\n            9,\n            6\n        ],\n        3: [\n            2,\n            7,\n            4\n        ],\n        4: [\n            6,\n            9,\n            5\n        ],\n        5: [\n            3,\n            8,\n            2\n        ],\n        6: [\n            10,\n            2,\n            3\n        ],\n        7: [\n            3,\n            5,\n            8\n        ],\n        8: [\n            4,\n            2,\n            7\n        ],\n        9: [\n            10,\n            3,\n            8\n        ] // Environmental Rights Activist: Indigenous Rights, Corporate Accountability, Protection in Conflict Zones\n    };\n    return recommendationMap[personalityTypeId] || [\n        1,\n        2,\n        3\n    ]; // Default recommendations if no match\n}\n/**\n * Generate a complete user result based on responses\n * @param responses Array of user responses\n * @returns Complete user result with personality type, dimension scores, and recommended causes\n */ function generateUserResult(responses, sessionId) {\n    // Calculate dimension scores\n    const dimensionScores = calculateDimensionScores(responses);\n    // Find matching personality type\n    const personalityTypeId = findMatchingPersonalityType(dimensionScores);\n    // Find recommended causes\n    const recommendedCauses = findRecommendedCauses(personalityTypeId);\n    return {\n        sessionId,\n        personalityTypeId,\n        dimensionScores,\n        recommendedCauses\n    };\n}\n/**\n * Generate an enhanced user result with all related data for display\n * @param responses Array of user responses\n * @param sessionId Session identifier\n * @returns Enhanced user result with full details for UI display\n */ function generateEnhancedUserResult(responses, sessionId) {\n    // Generate the basic user result\n    const userResult = generateUserResult(responses, sessionId);\n    // Get the personality type\n    const personalityType = _personalityTypes__WEBPACK_IMPORTED_MODULE_1__.personalityTypes.find((p)=>p.id === userResult.personalityTypeId);\n    // Format dimension details and sort by absolute score (highest first)\n    const dimensionDetails = Object.entries(userResult.dimensionScores).map((param)=>{\n        let [dimId, score] = param;\n        const dimension = _dimensions__WEBPACK_IMPORTED_MODULE_2__.dimensions.find((d)=>d.id === Number(dimId));\n        return {\n            dimension,\n            score,\n            description: score > 0 ? dimension === null || dimension === void 0 ? void 0 : dimension.highDescription : dimension === null || dimension === void 0 ? void 0 : dimension.lowDescription\n        };\n    }).sort((a, b)=>Math.abs(b.score) - Math.abs(a.score));\n    // Get the recommended causes\n    const causes = userResult.recommendedCauses.map((causeId)=>_amnestyCauses__WEBPACK_IMPORTED_MODULE_3__.amnestyCauses.find((c)=>c.id === causeId));\n    return {\n        userResult,\n        personalityType,\n        dimensionDetails,\n        causes\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvZGF0YS9wZXJzb25hbGl0eU1hdGNoaW5nLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLGtGQUFrRjtBQUVWO0FBQ2xCO0FBQ1o7QUFDTTtBQUVoRDs7OztDQUlDLEdBQ00sU0FBU0kseUJBQXlCQyxTQUF5QjtJQUNoRSw0Q0FBNEM7SUFDNUMsTUFBTUMsa0JBQTBDLENBQUM7SUFDakQsTUFBTUMsa0JBQTBDLENBQUM7SUFFakRMLG1EQUFVQSxDQUFDTSxPQUFPLENBQUNDLENBQUFBO1FBQ2pCSCxlQUFlLENBQUNHLFVBQVVDLEVBQUUsQ0FBQyxHQUFHO1FBQ2hDSCxlQUFlLENBQUNFLFVBQVVDLEVBQUUsQ0FBQyxHQUFHO0lBQ2xDO0lBRUEsd0JBQXdCO0lBQ3hCTCxVQUFVRyxPQUFPLENBQUNHLENBQUFBO1FBQ2hCLGdEQUFnRDtRQUNoRCxNQUFNQyxXQUFXWixpRkFBeUJBLENBQUNhLE1BQU0sQ0FDL0NDLENBQUFBLFVBQVdBLFFBQVFDLFVBQVUsS0FBS0osU0FBU0ksVUFBVTtRQUd2RCxrQ0FBa0M7UUFDbENILFNBQVNKLE9BQU8sQ0FBQ00sQ0FBQUE7WUFDZixvRUFBb0U7WUFDcEUsTUFBTUUsY0FBY0wsU0FBU00sS0FBSyxHQUFHSCxRQUFRSSxNQUFNLEdBQUcsQ0FBQ0osUUFBUUksTUFBTTtZQUNyRVosZUFBZSxDQUFDUSxRQUFRSyxXQUFXLENBQUMsSUFBSUg7WUFDeENULGVBQWUsQ0FBQ08sUUFBUUssV0FBVyxDQUFDLElBQUksaURBQWlEO1FBQzNGO0lBQ0Y7SUFFQSw4RkFBOEY7SUFDOUZqQixtREFBVUEsQ0FBQ00sT0FBTyxDQUFDQyxDQUFBQTtRQUNqQixNQUFNVyxRQUFRWCxVQUFVQyxFQUFFO1FBQzFCLE1BQU1XLFdBQVdmLGVBQWUsQ0FBQ2MsTUFBTTtRQUN2QyxNQUFNRSxnQkFBZ0JmLGVBQWUsQ0FBQ2EsTUFBTTtRQUU1QyxJQUFJRSxnQkFBZ0IsR0FBRztZQUNyQixrRUFB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QUFBQSxnQ0FBQUEsVUFBV21ELGVBQWUsR0FBR25ELHNCQUFBQSxnQ0FBQUEsVUFBV29ELGNBQWM7UUFDakY7SUFDRixHQUNDQyxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTXhDLEtBQUtnQixHQUFHLENBQUN3QixFQUFFcEIsS0FBSyxJQUFJcEIsS0FBS2dCLEdBQUcsQ0FBQ3VCLEVBQUVuQixLQUFLO0lBRXRELDZCQUE2QjtJQUM3QixNQUFNcUIsU0FBU2IsV0FBV0YsaUJBQWlCLENBQUNPLEdBQUcsQ0FBQ1MsQ0FBQUEsVUFDOUMvRCx5REFBYUEsQ0FBQ21ELElBQUksQ0FBQ2EsQ0FBQUEsSUFBS0EsRUFBRXpELEVBQUUsS0FBS3dEO0lBR25DLE9BQU87UUFDTGQ7UUFDQUM7UUFDQUc7UUFDQVM7SUFDRjtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvaGFxL2Rldi9hbW5lc3R5LWludGVyYWN0aXZlL2FtbmVzdHktYXBwL3NyYy9saWIvZGF0YS9wZXJzb25hbGl0eU1hdGNoaW5nLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFBlcnNvbmFsaXR5IG1hdGNoaW5nIGFsZ29yaXRobSBmb3IgQW1uZXN0eSBJbnRlcm5hdGlvbmFsIEludGVyYWN0aXZlIEV4cGVyaWVuY2VcbmltcG9ydCB7IFVzZXJSZXNwb25zZSwgVXNlclJlc3VsdCwgUXVlc3Rpb25EaW1lbnNpb25NYXBwaW5nLCBFbmhhbmNlZFVzZXJSZXN1bHQgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IHF1ZXN0aW9uRGltZW5zaW9uTWFwcGluZ3MgfSBmcm9tICcuL3F1ZXN0aW9uRGltZW5zaW9uTWFwcGluZ3MnO1xuaW1wb3J0IHsgcGVyc29uYWxpdHlUeXBlcyB9IGZyb20gJy4vcGVyc29uYWxpdHlUeXBlcyc7XG5pbXBvcnQgeyBkaW1lbnNpb25zIH0gZnJvbSAnLi9kaW1lbnNpb25zJztcbmltcG9ydCB7IGFtbmVzdHlDYXVzZXMgfSBmcm9tICcuL2FtbmVzdHlDYXVzZXMnO1xuXG4vKipcbiAqIENhbGN1bGF0ZSBkaW1lbnNpb24gc2NvcmVzIGJhc2VkIG9uIHVzZXIgcmVzcG9uc2VzXG4gKiBAcGFyYW0gcmVzcG9uc2VzIEFycmF5IG9mIHVzZXIgcmVzcG9uc2VzIChhZ3JlZS9kaXNhZ3JlZSlcbiAqIEByZXR1cm5zIE9iamVjdCBtYXBwaW5nIGRpbWVuc2lvbiBJRHMgdG8gc2NvcmVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVEaW1lbnNpb25TY29yZXMocmVzcG9uc2VzOiBVc2VyUmVzcG9uc2VbXSk6IFJlY29yZDxudW1iZXIsIG51bWJlcj4ge1xuICAvLyBJbml0aWFsaXplIHNjb3JlcyBmb3IgYWxsIGRpbWVuc2lvbnMgdG8gMFxuICBjb25zdCBkaW1lbnNpb25TY29yZXM6IFJlY29yZDxudW1iZXIsIG51bWJlcj4gPSB7fTtcbiAgY29uc3QgZGltZW5zaW9uQ291bnRzOiBSZWNvcmQ8bnVtYmVyLCBudW1iZXI+ID0ge307XG4gIFxuICBkaW1lbnNpb25zLmZvckVhY2goZGltZW5zaW9uID0+IHtcbiAgICBkaW1lbnNpb25TY29yZXNbZGltZW5zaW9uLmlkXSA9IDA7XG4gICAgZGltZW5zaW9uQ291bnRzW2RpbWVuc2lvbi5pZF0gPSAwO1xuICB9KTtcblxuICAvLyBQcm9jZXNzIGVhY2ggcmVzcG9uc2VcbiAgcmVzcG9uc2VzLmZvckVhY2gocmVzcG9uc2UgPT4ge1xuICAgIC8vIEZpbmQgYWxsIGRpbWVuc2lvbiBtYXBwaW5ncyBmb3IgdGhpcyBxdWVzdGlvblxuICAgIGNvbnN0IG1hcHBpbmdzID0gcXVlc3Rpb25EaW1lbnNpb25NYXBwaW5ncy5maWx0ZXIoXG4gICAgICBtYXBwaW5nID0+IG1hcHBpbmcucXVlc3Rpb25JZCA9PT0gcmVzcG9uc2UucXVlc3Rpb25JZFxuICAgICk7XG5cbiAgICAvLyBVcGRhdGUgc2NvcmVzIGJhc2VkIG9uIHJlc3BvbnNlXG4gICAgbWFwcGluZ3MuZm9yRWFjaChtYXBwaW5nID0+IHtcbiAgICAgIC8vIElmIHVzZXIgYWdyZWVzLCBhZGQgdGhlIHdlaWdodDsgaWYgZGlzYWdyZWVzLCBzdWJ0cmFjdCB0aGUgd2VpZ2h0XG4gICAgICBjb25zdCBzY29yZUNoYW5nZSA9IHJlc3BvbnNlLmFncmVlID8gbWFwcGluZy53ZWlnaHQgOiAtbWFwcGluZy53ZWlnaHQ7XG4gICAgICBkaW1lbnNpb25TY29yZXNbbWFwcGluZy5kaW1lbnNpb25JZF0gKz0gc2NvcmVDaGFuZ2U7XG4gICAgICBkaW1lbnNpb25Db3VudHNbbWFwcGluZy5kaW1lbnNpb25JZF0rKzsgLy8gQ291bnQgaG93IG1hbnkgcXVlc3Rpb25zIGFmZmVjdCBlYWNoIGRpbWVuc2lvblxuICAgIH0pO1xuICB9KTtcblxuICAvLyBOb3JtYWxpemUgc2NvcmVzIHRvIGEgc2NhbGUgb2YgLTEwIHRvIDEwLCBidXQgYWNjb3VudCBmb3IgbnVtYmVyIG9mIHF1ZXN0aW9ucyBwZXIgZGltZW5zaW9uXG4gIGRpbWVuc2lvbnMuZm9yRWFjaChkaW1lbnNpb24gPT4ge1xuICAgIGNvbnN0IGRpbUlkID0gZGltZW5zaW9uLmlkO1xuICAgIGNvbnN0IHJhd1Njb3JlID0gZGltZW5zaW9uU2NvcmVzW2RpbUlkXTtcbiAgICBjb25zdCBxdWVzdGlvbkNvdW50ID0gZGltZW5zaW9uQ291bnRzW2RpbUlkXTtcbiAgICBcbiAgICBpZiAocXVlc3Rpb25Db3VudCA+IDApIHtcbiAgICAgIC8vIE5vcm1hbGl6ZSBiYXNlZCBvbiBhY3R1YWwgcXVlc3Rpb25zIGFuc3dlcmVkIGZvciB0aGlzIGRpbWVuc2lvblxuICAgICAgLy8gVGhpcyBwcmV2ZW50cyBkaW1lbnNpb25zIHdpdGggZmV3ZXIgcXVlc3Rpb25zIGZyb20gYmVpbmcgdW5kZXItcmVwcmVzZW50ZWRcbiAgICAgIGNvbnN0IGF2Z1Njb3JlUGVyUXVlc3Rpb24gPSByYXdTY29yZSAvIHF1ZXN0aW9uQ291bnQ7XG4gICAgICBcbiAgICAgIC8vIFNjYWxlIHRvIC0xMCB0byAxMCByYW5nZSwgd2l0aCBhIGZhY3RvciB0byBtYWtlIHNjb3JlcyBtb3JlIHByb25vdW5jZWRcbiAgICAgIC8vIFRoZSAzIGlzIGJhc2VkIG9uIG91ciB3ZWlnaHQgc2NhbGUgb2YgLTMgdG8gM1xuICAgICAgZGltZW5zaW9uU2NvcmVzW2RpbUlkXSA9IE1hdGgubWF4KC0xMCwgTWF0aC5taW4oMTAsIGF2Z1Njb3JlUGVyUXVlc3Rpb24gKiAoMTAvMykpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm8gcXVlc3Rpb25zIGFmZmVjdGVkIHRoaXMgZGltZW5zaW9uLCBsZWF2ZSBpdCBhdCAwXG4gICAgICBkaW1lbnNpb25TY29yZXNbZGltSWRdID0gMDtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBkaW1lbnNpb25TY29yZXM7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSBiZXN0IG1hdGNoaW5nIHBlcnNvbmFsaXR5IHR5cGUgYmFzZWQgb24gZGltZW5zaW9uIHNjb3Jlc1xuICogQHBhcmFtIGRpbWVuc2lvblNjb3JlcyBPYmplY3QgbWFwcGluZyBkaW1lbnNpb24gSURzIHRvIHNjb3Jlc1xuICogQHJldHVybnMgSUQgb2YgdGhlIGJlc3QgbWF0Y2hpbmcgcGVyc29uYWxpdHkgdHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZE1hdGNoaW5nUGVyc29uYWxpdHlUeXBlKGRpbWVuc2lvblNjb3JlczogUmVjb3JkPG51bWJlciwgbnVtYmVyPik6IG51bWJlciB7XG4gIC8vIFBlcnNvbmFsaXR5IHR5cGUgbWF0Y2hpbmcgcHJvZmlsZXNcbiAgLy8gRWFjaCBwcm9maWxlIGRlZmluZXMgdGhlIGV4cGVjdGVkIGRpbWVuc2lvbiBzY29yZXMgZm9yIGEgcGVyc29uYWxpdHkgdHlwZVxuICBjb25zdCBwZXJzb25hbGl0eVByb2ZpbGVzOiBSZWNvcmQ8bnVtYmVyLCBSZWNvcmQ8bnVtYmVyLCBudW1iZXI+PiA9IHtcbiAgICAvLyBEZW4gR2xvYmFsZSBBa3RpdmlzdGVuIChUaGUgR2xvYmFsIEFjdGl2aXN0KVxuICAgIDE6IHtcbiAgICAgIDE6IDgsICAvLyBIaWdoIG9uIGFjdGl2aXNtXG4gICAgICAyOiA5LCAgLy8gSGlnaCBvbiB1bml2ZXJzYWwgdmFsdWVzXG4gICAgICAzOiA1LCAgLy8gTW9kZXJhdGUgb24gaW5kaXZpZHVhbCBsaWJlcnR5XG4gICAgICA0OiAtNywgLy8gTG93IG9uIHNvdmVyZWlnbnR5IChmYXZvcnMgaW50ZXJuYXRpb25hbCBpbnRlcnZlbnRpb24pXG4gICAgICA1OiA2LCAgLy8gTW9kZXJhdGVseSBoaWdoIG9uIGVxdWFsaXR5XG4gICAgICA2OiAtMywgLy8gU2xpZ2h0bHkgbG93IG9uIHNlY3VyaXR5IChmYXZvcnMgcHJpdmFjeSlcbiAgICAgIDc6IDQsICAvLyBNb2RlcmF0ZSBvbiBlbXBhdGh5XG4gICAgICA4OiA3LCAgLy8gSGlnaCBvbiBlY29ub21pYyBqdXN0aWNlXG4gICAgICA5OiA4LCAgLy8gSGlnaCBvbiBodW1hbml0eVxuICAgICAgMTA6IDAgIC8vIE5ldXRyYWwgb24gcmVmb3JtIHZzIHN5c3RlbSBjaGFuZ2VcbiAgICB9LFxuICAgIFxuICAgIC8vIERlbiBNZWRmw7hsZW5kZSBGb3JzdmFyZXJlbiAoVGhlIENvbXBhc3Npb25hdGUgRGVmZW5kZXIpXG4gICAgMjoge1xuICAgICAgMTogMywgIC8vIE1vZGVyYXRlIG9uIGFjdGl2aXNtXG4gICAgICAyOiA2LCAgLy8gTW9kZXJhdGVseSBoaWdoIG9uIHVuaXZlcnNhbCB2YWx1ZXNcbiAgICAgIDM6IDIsICAvLyBTbGlnaHRseSBwb3NpdGl2ZSBvbiBpbmRpdmlkdWFsIGxpYmVydHlcbiAgICAgIDQ6IC0yLCAvLyBTbGlnaHRseSBsb3cgb24gc292ZXJlaWdudHlcbiAgICAgIDU6IDUsICAvLyBNb2RlcmF0ZWx5IGhpZ2ggb24gZXF1YWxpdHlcbiAgICAgIDY6IC0xLCAvLyBTbGlnaHRseSBsb3cgb24gc2VjdXJpdHlcbiAgICAgIDc6IDksICAvLyBWZXJ5IGhpZ2ggb24gZW1wYXRoeVxuICAgICAgODogNCwgIC8vIE1vZGVyYXRlIG9uIGVjb25vbWljIGp1c3RpY2VcbiAgICAgIDk6IDksICAvLyBWZXJ5IGhpZ2ggb24gaHVtYW5pdHlcbiAgICAgIDEwOiAzICAvLyBNb2RlcmF0ZSBvbiByZWZvcm1cbiAgICB9LFxuICAgIFxuICAgIC8vIEZyaWhldHNmb3JramVtcGVyZW4gKFRoZSBMaWJlcnR5IEFkdm9jYXRlKVxuICAgIDM6IHtcbiAgICAgIDE6IDUsICAvLyBNb2RlcmF0ZWx5IGhpZ2ggb24gYWN0aXZpc21cbiAgICAgIDI6IDMsICAvLyBNb2RlcmF0ZSBvbiB1bml2ZXJzYWwgdmFsdWVzXG4gICAgICAzOiAxMCwgLy8gVmVyeSBoaWdoIG9uIGluZGl2aWR1YWwgbGliZXJ0eVxuICAgICAgNDogMiwgIC8vIFNsaWdodGx5IGhpZ2ggb24gc292ZXJlaWdudHlcbiAgICAgIDU6IC01LCAvLyBMb3cgb24gZXF1YWxpdHkgKGZhdm9ycyBsaWJlcnR5KVxuICAgICAgNjogLTksIC8vIFZlcnkgbG93IG9uIHNlY3VyaXR5IChzdHJvbmdseSBmYXZvcnMgcHJpdmFjeSlcbiAgICAgIDc6IDAsICAvLyBOZXV0cmFsIG9uIGVtcGF0aHkgdnMgcHJpbmNpcGxlc1xuICAgICAgODogLTcsIC8vIExvdyBvbiBlY29ub21pYyBqdXN0aWNlIChmYXZvcnMgbWFya2V0IGZyZWVkb20pXG4gICAgICA5OiAzLCAgLy8gTW9kZXJhdGUgb24gaHVtYW5pdHlcbiAgICAgIDEwOiAwICAvLyBOZXV0cmFsIG9uIHJlZm9ybSB2cyBzeXN0ZW0gY2hhbmdlXG4gICAgfSxcbiAgICBcbiAgICAvLyBMaWtlc3RpbGxpbmdzZm9ya2plbXBlcmVuIChUaGUgRXF1YWxpdHkgQ2hhbXBpb24pXG4gICAgNDoge1xuICAgICAgMTogNiwgIC8vIE1vZGVyYXRlbHkgaGlnaCBvbiBhY3RpdmlzbVxuICAgICAgMjogNywgIC8vIEhpZ2ggb24gdW5pdmVyc2FsIHZhbHVlc1xuICAgICAgMzogMCwgIC8vIE5ldXRyYWwgb24gaW5kaXZpZHVhbCBsaWJlcnR5IHZzIGNvbGxlY3RpdmUgcmVzcG9uc2liaWxpdHlcbiAgICAgIDQ6IC0zLCAvLyBNb2RlcmF0ZWx5IGxvdyBvbiBzb3ZlcmVpZ250eVxuICAgICAgNTogMTAsIC8vIFZlcnkgaGlnaCBvbiBlcXVhbGl0eVxuICAgICAgNjogMCwgIC8vIE5ldXRyYWwgb24gc2VjdXJpdHkgdnMgcHJpdmFjeVxuICAgICAgNzogNSwgIC8vIE1vZGVyYXRlbHkgaGlnaCBvbiBlbXBhdGh5XG4gICAgICA4OiA4LCAgLy8gSGlnaCBvbiBlY29ub21pYyBqdXN0aWNlXG4gICAgICA5OiA2LCAgLy8gTW9kZXJhdGVseSBoaWdoIG9uIGh1bWFuaXR5XG4gICAgICAxMDogNCAgLy8gTW9kZXJhdGUgb24gcmVmb3JtXG4gICAgfSxcbiAgICBcbiAgICAvLyBEZW4gUHJhZ21hdGlza2UgUmVmb3JtYXRvcmVuIChUaGUgUHJhZ21hdGljIFJlZm9ybWVyKVxuICAgIDU6IHtcbiAgICAgIDE6IC02LCAvLyBMb3cgb24gYWN0aXZpc20gKGZhdm9ycyBncmFkdWFsIGNoYW5nZSlcbiAgICAgIDI6IDIsICAvLyBTbGlnaHRseSBwb3NpdGl2ZSBvbiB1bml2ZXJzYWwgdmFsdWVzXG4gICAgICAzOiAwLCAgLy8gTmV1dHJhbCBvbiBpbmRpdmlkdWFsIGxpYmVydHkgdnMgY29sbGVjdGl2ZSByZXNwb25zaWJpbGl0eVxuICAgICAgNDogMywgIC8vIE1vZGVyYXRlIG9uIHNvdmVyZWlnbnR5XG4gICAgICA1OiAyLCAgLy8gU2xpZ2h0bHkgcG9zaXRpdmUgb24gZXF1YWxpdHlcbiAgICAgIDY6IDMsICAvLyBNb2RlcmF0ZSBvbiBzZWN1cml0eVxuICAgICAgNzogLTIsIC8vIFNsaWdodGx5IGxvdyBvbiBlbXBhdGh5IChmYXZvcnMgcHJpbmNpcGxlcylcbiAgICAgIDg6IDAsICAvLyBOZXV0cmFsIG9uIGVjb25vbWljIGp1c3RpY2UgdnMgbWFya2V0IGZyZWVkb21cbiAgICAgIDk6IC01LCAvLyBMb3cgb24gaHVtYW5pdHkgKGZhdm9ycyBwcmFnbWF0aXNtKVxuICAgICAgMTA6IDkgIC8vIFZlcnkgaGlnaCBvbiByZWZvcm1cbiAgICB9LFxuICAgIFxuICAgIC8vIFRyYWRpc2pvbnN2b2t0ZXJlbiAoVGhlIFRyYWRpdGlvbiBHdWFyZGlhbilcbiAgICA2OiB7XG4gICAgICAxOiAtOCwgLy8gVmVyeSBsb3cgb24gYWN0aXZpc20gKHN0cm9uZ2x5IGZhdm9ycyBncmFkdWFsIGNoYW5nZSlcbiAgICAgIDI6IC05LCAvLyBWZXJ5IGxvdyBvbiB1bml2ZXJzYWwgdmFsdWVzIChzdHJvbmdseSBmYXZvcnMgY3VsdHVyYWwgcmVsYXRpdmlzbSlcbiAgICAgIDM6IC0zLCAvLyBNb2RlcmF0ZWx5IGxvdyBvbiBpbmRpdmlkdWFsIGxpYmVydHkgKGZhdm9ycyBjb2xsZWN0aXZlIHJlc3BvbnNpYmlsaXR5KVxuICAgICAgNDogOSwgIC8vIFZlcnkgaGlnaCBvbiBzb3ZlcmVpZ250eVxuICAgICAgNTogLTQsIC8vIE1vZGVyYXRlbHkgbG93IG9uIGVxdWFsaXR5IChmYXZvcnMgbGliZXJ0eSlcbiAgICAgIDY6IDcsICAvLyBIaWdoIG9uIHNlY3VyaXR5XG4gICAgICA3OiAtMywgLy8gTW9kZXJhdGVseSBsb3cgb24gZW1wYXRoeSAoZmF2b3JzIHByaW5jaXBsZXMpXG4gICAgICA4OiAtNSwgLy8gTG93IG9uIGVjb25vbWljIGp1c3RpY2UgKGZhdm9ycyBtYXJrZXQgZnJlZWRvbSlcbiAgICAgIDk6IC0yLCAvLyBTbGlnaHRseSBsb3cgb24gaHVtYW5pdHkgKGZhdm9ycyBwcmFnbWF0aXNtKVxuICAgICAgMTA6IDIgIC8vIFNsaWdodGx5IHBvc2l0aXZlIG9uIHJlZm9ybVxuICAgIH0sXG4gICAgXG4gICAgLy8gU3lzdGVta3JpdGlrZXJlbiAoVGhlIFN5c3RlbSBDcml0aWMpXG4gICAgNzoge1xuICAgICAgMTogNywgIC8vIEhpZ2ggb24gYWN0aXZpc21cbiAgICAgIDI6IDQsICAvLyBNb2RlcmF0ZSBvbiB1bml2ZXJzYWwgdmFsdWVzXG4gICAgICAzOiAtMiwgLy8gU2xpZ2h0bHkgbG93IG9uIGluZGl2aWR1YWwgbGliZXJ0eSAoZmF2b3JzIGNvbGxlY3RpdmUgcmVzcG9uc2liaWxpdHkpXG4gICAgICA0OiAwLCAgLy8gTmV1dHJhbCBvbiBzb3ZlcmVpZ250eVxuICAgICAgNTogOCwgIC8vIEhpZ2ggb24gZXF1YWxpdHlcbiAgICAgIDY6IC00LCAvLyBNb2RlcmF0ZWx5IGxvdyBvbiBzZWN1cml0eSAoZmF2b3JzIHByaXZhY3kpXG4gICAgICA3OiAzLCAgLy8gTW9kZXJhdGUgb24gZW1wYXRoeVxuICAgICAgODogMTAsIC8vIFZlcnkgaGlnaCBvbiBlY29ub21pYyBqdXN0aWNlXG4gICAgICA5OiA1LCAgLy8gTW9kZXJhdGVseSBoaWdoIG9uIGh1bWFuaXR5XG4gICAgICAxMDogLTkgLy8gVmVyeSBsb3cgb24gcmVmb3JtIChzdHJvbmdseSBmYXZvcnMgc3lzdGVtIGNoYW5nZSlcbiAgICB9LFxuICAgIFxuICAgIC8vIFJldHRzdGF0c2ZvcmtqZW1wZXJlbiAoVGhlIFJ1bGUgb2YgTGF3IEFkdm9jYXRlKVxuICAgIDg6IHtcbiAgICAgIDE6IC03LCAvLyBMb3cgb24gYWN0aXZpc20gKGZhdm9ycyBncmFkdWFsIGNoYW5nZSlcbiAgICAgIDI6IDUsICAvLyBNb2RlcmF0ZWx5IGhpZ2ggb24gdW5pdmVyc2FsIHZhbHVlc1xuICAgICAgMzogMywgIC8vIE1vZGVyYXRlIG9uIGluZGl2aWR1YWwgbGliZXJ0eVxuICAgICAgNDogNCwgIC8vIE1vZGVyYXRlIG9uIHNvdmVyZWlnbnR5XG4gICAgICA1OiA2LCAgLy8gTW9kZXJhdGVseSBoaWdoIG9uIGVxdWFsaXR5XG4gICAgICA2OiA1LCAgLy8gTW9kZXJhdGVseSBoaWdoIG9uIHNlY3VyaXR5XG4gICAgICA3OiAtNSwgLy8gTG93IG9uIGVtcGF0aHkgKGZhdm9ycyBwcmluY2lwbGVzKVxuICAgICAgODogMiwgIC8vIFNsaWdodGx5IHBvc2l0aXZlIG9uIGVjb25vbWljIGp1c3RpY2VcbiAgICAgIDk6IDAsICAvLyBOZXV0cmFsIG9uIGh1bWFuaXR5IHZzIHByYWdtYXRpc21cbiAgICAgIDEwOiA4ICAvLyBIaWdoIG9uIHJlZm9ybVxuICAgIH0sXG4gICAgXG4gICAgLy8gTWlsasO4cmV0dGlnaGV0c2FrdGl2aXN0ZW4gKFRoZSBFbnZpcm9ubWVudGFsIFJpZ2h0cyBBY3RpdmlzdClcbiAgICA5OiB7XG4gICAgICAxOiA4LCAgLy8gSGlnaCBvbiBhY3RpdmlzbVxuICAgICAgMjogNiwgIC8vIE1vZGVyYXRlbHkgaGlnaCBvbiB1bml2ZXJzYWwgdmFsdWVzXG4gICAgICAzOiAtNCwgLy8gTW9kZXJhdGVseSBsb3cgb24gaW5kaXZpZHVhbCBsaWJlcnR5IChmYXZvcnMgY29sbGVjdGl2ZSByZXNwb25zaWJpbGl0eSlcbiAgICAgIDQ6IC0yLCAvLyBTbGlnaHRseSBsb3cgb24gc292ZXJlaWdudHlcbiAgICAgIDU6IDUsICAvLyBNb2RlcmF0ZWx5IGhpZ2ggb24gZXF1YWxpdHlcbiAgICAgIDY6IDAsICAvLyBOZXV0cmFsIG9uIHNlY3VyaXR5IHZzIHByaXZhY3lcbiAgICAgIDc6IDcsICAvLyBIaWdoIG9uIGVtcGF0aHlcbiAgICAgIDg6IDYsICAvLyBNb2RlcmF0ZWx5IGhpZ2ggb24gZWNvbm9taWMganVzdGljZVxuICAgICAgOTogOCwgIC8vIEhpZ2ggb24gaHVtYW5pdHlcbiAgICAgIDEwOiAtNiAvLyBMb3cgb24gcmVmb3JtIChmYXZvcnMgc3lzdGVtIGNoYW5nZSlcbiAgICB9XG4gIH07XG5cbiAgLy8gQ2FsY3VsYXRlIHNpbWlsYXJpdHkgc2NvcmVzIGZvciBlYWNoIHBlcnNvbmFsaXR5IHR5cGVcbiAgY29uc3Qgc2ltaWxhcml0eVNjb3JlczogUmVjb3JkPG51bWJlciwgbnVtYmVyPiA9IHt9O1xuICBcbiAgT2JqZWN0LmVudHJpZXMocGVyc29uYWxpdHlQcm9maWxlcykuZm9yRWFjaCgoW3R5cGVJZCwgcHJvZmlsZV0pID0+IHtcbiAgICBsZXQgc2ltaWxhcml0eSA9IDA7XG4gICAgbGV0IHdlaWdodHNTdW0gPSAwO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSB3ZWlnaHRlZCBFdWNsaWRlYW4gZGlzdGFuY2UgKGxvd2VyIGlzIGJldHRlcilcbiAgICBPYmplY3QuZW50cmllcyhwcm9maWxlKS5mb3JFYWNoKChbZGltZW5zaW9uSWQsIGV4cGVjdGVkU2NvcmVdKSA9PiB7XG4gICAgICBjb25zdCBkaW1JZCA9IE51bWJlcihkaW1lbnNpb25JZCk7XG4gICAgICBjb25zdCB1c2VyU2NvcmUgPSBkaW1lbnNpb25TY29yZXNbZGltSWRdIHx8IDA7XG4gICAgICBjb25zdCBkaWZmZXJlbmNlID0gdXNlclNjb3JlIC0gZXhwZWN0ZWRTY29yZTtcbiAgICAgIFxuICAgICAgLy8gR2l2ZSBtb3JlIHdlaWdodCB0byBleHRyZW1lIGV4cGVjdGVkIHNjb3JlcyAodmFsdWVzIG5lYXIgLTEwIG9yIDEwKVxuICAgICAgLy8gVGhlc2UgYXJlIG1vcmUgZGVmaW5pbmcgY2hhcmFjdGVyaXN0aWNzIG9mIHBlcnNvbmFsaXR5IHR5cGVzXG4gICAgICBjb25zdCB3ZWlnaHQgPSBNYXRoLmFicyhleHBlY3RlZFNjb3JlKSAvIDU7XG4gICAgICB3ZWlnaHRzU3VtICs9IHdlaWdodDtcbiAgICAgIFxuICAgICAgc2ltaWxhcml0eSAtPSAoZGlmZmVyZW5jZSAqIGRpZmZlcmVuY2UgKiB3ZWlnaHQpOyAvLyBOZWdhdGl2ZSB3ZWlnaHRlZCBzcXVhcmVkIGRpZmZlcmVuY2VcbiAgICB9KTtcbiAgICBcbiAgICAvLyBOb3JtYWxpemUgYnkgc3VtIG9mIHdlaWdodHMgdG8gbWFrZSBjb21wYXJpc29uIGZhaXJcbiAgICBpZiAod2VpZ2h0c1N1bSA+IDApIHtcbiAgICAgIHNpbWlsYXJpdHkgPSBzaW1pbGFyaXR5IC8gd2VpZ2h0c1N1bTtcbiAgICB9XG4gICAgXG4gICAgc2ltaWxhcml0eVNjb3Jlc1tOdW1iZXIodHlwZUlkKV0gPSBzaW1pbGFyaXR5O1xuICB9KTtcbiAgXG4gIC8vIEZpbmQgcGVyc29uYWxpdHkgdHlwZSB3aXRoIGhpZ2hlc3Qgc2ltaWxhcml0eSBzY29yZVxuICBsZXQgYmVzdE1hdGNoVHlwZUlkID0gMTtcbiAgbGV0IGhpZ2hlc3RTaW1pbGFyaXR5ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICBcbiAgT2JqZWN0LmVudHJpZXMoc2ltaWxhcml0eVNjb3JlcykuZm9yRWFjaCgoW3R5cGVJZCwgc2NvcmVdKSA9PiB7XG4gICAgaWYgKHNjb3JlID4gaGlnaGVzdFNpbWlsYXJpdHkpIHtcbiAgICAgIGhpZ2hlc3RTaW1pbGFyaXR5ID0gc2NvcmU7XG4gICAgICBiZXN0TWF0Y2hUeXBlSWQgPSBOdW1iZXIodHlwZUlkKTtcbiAgICB9XG4gIH0pO1xuICBcbiAgcmV0dXJuIGJlc3RNYXRjaFR5cGVJZDtcbn1cblxuLyoqXG4gKiBGaW5kIHJlY29tbWVuZGVkIEFtbmVzdHkgY2F1c2VzIGJhc2VkIG9uIHBlcnNvbmFsaXR5IHR5cGVcbiAqIEBwYXJhbSBwZXJzb25hbGl0eVR5cGVJZCBJRCBvZiB0aGUgbWF0Y2hlZCBwZXJzb25hbGl0eSB0eXBlXG4gKiBAcmV0dXJucyBBcnJheSBvZiByZWNvbW1lbmRlZCBjYXVzZSBJRHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRSZWNvbW1lbmRlZENhdXNlcyhwZXJzb25hbGl0eVR5cGVJZDogbnVtYmVyKTogbnVtYmVyW10ge1xuICAvLyBNYXBwaW5nIG9mIHBlcnNvbmFsaXR5IHR5cGVzIHRvIHJlY29tbWVuZGVkIGNhdXNlc1xuICAvLyBJbiBhIHJlYWwgaW1wbGVtZW50YXRpb24sIHRoaXMgd291bGQgY29tZSBmcm9tIHRoZSBkYXRhYmFzZVxuICBjb25zdCByZWNvbW1lbmRhdGlvbk1hcDogUmVjb3JkPG51bWJlciwgbnVtYmVyW10+ID0ge1xuICAgIDE6IFsxLCA0LCA4XSwgICAgLy8gR2xvYmFsIEFjdGl2aXN0OiBSZWZ1Z2VlIFJpZ2h0cywgRGVhdGggUGVuYWx0eSBBYm9saXRpb24sIFByb3RlY3Rpb24gaW4gQ29uZmxpY3QgWm9uZXNcbiAgICAyOiBbMSwgOSwgNl0sICAgIC8vIENvbXBhc3Npb25hdGUgRGVmZW5kZXI6IFJlZnVnZWUgUmlnaHRzLCBXb21lbidzIFJpZ2h0cywgTEdCVFErIFJpZ2h0c1xuICAgIDM6IFsyLCA3LCA0XSwgICAgLy8gTGliZXJ0eSBBZHZvY2F0ZTogRnJlZWRvbSBvZiBFeHByZXNzaW9uLCBQcml2YWN5IGFuZCBTdXJ2ZWlsbGFuY2UsIERlYXRoIFBlbmFsdHkgQWJvbGl0aW9uXG4gICAgNDogWzYsIDksIDVdLCAgICAvLyBFcXVhbGl0eSBDaGFtcGlvbjogTEdCVFErIFJpZ2h0cywgV29tZW4ncyBSaWdodHMsIEZyZWVkb20gb2YgQXNzZW1ibHlcbiAgICA1OiBbMywgOCwgMl0sICAgIC8vIFByYWdtYXRpYyBSZWZvcm1lcjogQ29ycG9yYXRlIEFjY291bnRhYmlsaXR5LCBQcm90ZWN0aW9uIGluIENvbmZsaWN0IFpvbmVzLCBGcmVlZG9tIG9mIEV4cHJlc3Npb25cbiAgICA2OiBbMTAsIDIsIDNdLCAgIC8vIFRyYWRpdGlvbiBHdWFyZGlhbjogSW5kaWdlbm91cyBSaWdodHMsIEZyZWVkb20gb2YgRXhwcmVzc2lvbiwgQ29ycG9yYXRlIEFjY291bnRhYmlsaXR5XG4gICAgNzogWzMsIDUsIDhdLCAgICAvLyBTeXN0ZW0gQ3JpdGljOiBDb3Jwb3JhdGUgQWNjb3VudGFiaWxpdHksIEZyZWVkb20gb2YgQXNzZW1ibHksIFByb3RlY3Rpb24gaW4gQ29uZmxpY3QgWm9uZXNcbiAgICA4OiBbNCwgMiwgN10sICAgIC8vIFJ1bGUgb2YgTGF3IEFkdm9jYXRlOiBEZWF0aCBQZW5hbHR5IEFib2xpdGlvbiwgRnJlZWRvbSBvZiBFeHByZXNzaW9uLCBQcml2YWN5IGFuZCBTdXJ2ZWlsbGFuY2VcbiAgICA5OiBbMTAsIDMsIDhdICAgIC8vIEVudmlyb25tZW50YWwgUmlnaHRzIEFjdGl2aXN0OiBJbmRpZ2Vub3VzIFJpZ2h0cywgQ29ycG9yYXRlIEFjY291bnRhYmlsaXR5LCBQcm90ZWN0aW9uIGluIENvbmZsaWN0IFpvbmVzXG4gIH07XG4gIFxuICByZXR1cm4gcmVjb21tZW5kYXRpb25NYXBbcGVyc29uYWxpdHlUeXBlSWRdIHx8IFsxLCAyLCAzXTsgLy8gRGVmYXVsdCByZWNvbW1lbmRhdGlvbnMgaWYgbm8gbWF0Y2hcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGNvbXBsZXRlIHVzZXIgcmVzdWx0IGJhc2VkIG9uIHJlc3BvbnNlc1xuICogQHBhcmFtIHJlc3BvbnNlcyBBcnJheSBvZiB1c2VyIHJlc3BvbnNlc1xuICogQHJldHVybnMgQ29tcGxldGUgdXNlciByZXN1bHQgd2l0aCBwZXJzb25hbGl0eSB0eXBlLCBkaW1lbnNpb24gc2NvcmVzLCBhbmQgcmVjb21tZW5kZWQgY2F1c2VzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVVzZXJSZXN1bHQocmVzcG9uc2VzOiBVc2VyUmVzcG9uc2VbXSwgc2Vzc2lvbklkOiBzdHJpbmcpOiBVc2VyUmVzdWx0IHtcbiAgLy8gQ2FsY3VsYXRlIGRpbWVuc2lvbiBzY29yZXNcbiAgY29uc3QgZGltZW5zaW9uU2NvcmVzID0gY2FsY3VsYXRlRGltZW5zaW9uU2NvcmVzKHJlc3BvbnNlcyk7XG4gIFxuICAvLyBGaW5kIG1hdGNoaW5nIHBlcnNvbmFsaXR5IHR5cGVcbiAgY29uc3QgcGVyc29uYWxpdHlUeXBlSWQgPSBmaW5kTWF0Y2hpbmdQZXJzb25hbGl0eVR5cGUoZGltZW5zaW9uU2NvcmVzKTtcbiAgXG4gIC8vIEZpbmQgcmVjb21tZW5kZWQgY2F1c2VzXG4gIGNvbnN0IHJlY29tbWVuZGVkQ2F1c2VzID0gZmluZFJlY29tbWVuZGVkQ2F1c2VzKHBlcnNvbmFsaXR5VHlwZUlkKTtcbiAgXG4gIHJldHVybiB7XG4gICAgc2Vzc2lvbklkLFxuICAgIHBlcnNvbmFsaXR5VHlwZUlkLFxuICAgIGRpbWVuc2lvblNjb3JlcyxcbiAgICByZWNvbW1lbmRlZENhdXNlc1xuICB9O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGFuIGVuaGFuY2VkIHVzZXIgcmVzdWx0IHdpdGggYWxsIHJlbGF0ZWQgZGF0YSBmb3IgZGlzcGxheVxuICogQHBhcmFtIHJlc3BvbnNlcyBBcnJheSBvZiB1c2VyIHJlc3BvbnNlc1xuICogQHBhcmFtIHNlc3Npb25JZCBTZXNzaW9uIGlkZW50aWZpZXJcbiAqIEByZXR1cm5zIEVuaGFuY2VkIHVzZXIgcmVzdWx0IHdpdGggZnVsbCBkZXRhaWxzIGZvciBVSSBkaXNwbGF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUVuaGFuY2VkVXNlclJlc3VsdChyZXNwb25zZXM6IFVzZXJSZXNwb25zZVtdLCBzZXNzaW9uSWQ6IHN0cmluZyk6IEVuaGFuY2VkVXNlclJlc3VsdCB7XG4gIC8vIEdlbmVyYXRlIHRoZSBiYXNpYyB1c2VyIHJlc3VsdFxuICBjb25zdCB1c2VyUmVzdWx0ID0gZ2VuZXJhdGVVc2VyUmVzdWx0KHJlc3BvbnNlcywgc2Vzc2lvbklkKTtcbiAgXG4gIC8vIEdldCB0aGUgcGVyc29uYWxpdHkgdHlwZVxuICBjb25zdCBwZXJzb25hbGl0eVR5cGUgPSBwZXJzb25hbGl0eVR5cGVzLmZpbmQocCA9PiBwLmlkID09PSB1c2VyUmVzdWx0LnBlcnNvbmFsaXR5VHlwZUlkKTtcbiAgXG4gIC8vIEZvcm1hdCBkaW1lbnNpb24gZGV0YWlscyBhbmQgc29ydCBieSBhYnNvbHV0ZSBzY29yZSAoaGlnaGVzdCBmaXJzdClcbiAgY29uc3QgZGltZW5zaW9uRGV0YWlscyA9IE9iamVjdC5lbnRyaWVzKHVzZXJSZXN1bHQuZGltZW5zaW9uU2NvcmVzKVxuICAgIC5tYXAoKFtkaW1JZCwgc2NvcmVdKSA9PiB7XG4gICAgICBjb25zdCBkaW1lbnNpb24gPSBkaW1lbnNpb25zLmZpbmQoZCA9PiBkLmlkID09PSBOdW1iZXIoZGltSWQpKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpbWVuc2lvbixcbiAgICAgICAgc2NvcmUsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBzY29yZSA+IDAgPyBkaW1lbnNpb24/LmhpZ2hEZXNjcmlwdGlvbiA6IGRpbWVuc2lvbj8ubG93RGVzY3JpcHRpb25cbiAgICAgIH07XG4gICAgfSlcbiAgICAuc29ydCgoYSwgYikgPT4gTWF0aC5hYnMoYi5zY29yZSkgLSBNYXRoLmFicyhhLnNjb3JlKSk7XG4gIFxuICAvLyBHZXQgdGhlIHJlY29tbWVuZGVkIGNhdXNlc1xuICBjb25zdCBjYXVzZXMgPSB1c2VyUmVzdWx0LnJlY29tbWVuZGVkQ2F1c2VzLm1hcChjYXVzZUlkID0+IFxuICAgIGFtbmVzdHlDYXVzZXMuZmluZChjID0+IGMuaWQgPT09IGNhdXNlSWQpXG4gICk7XG4gIFxuICByZXR1cm4ge1xuICAgIHVzZXJSZXN1bHQsXG4gICAgcGVyc29uYWxpdHlUeXBlLFxuICAgIGRpbWVuc2lvbkRldGFpbHMsXG4gICAgY2F1c2VzXG4gIH07XG59XG4iXSwibmFtZXMiOlsicXVlc3Rpb25EaW1lbnNpb25NYXBwaW5ncyIsInBlcnNvbmFsaXR5VHlwZXMiLCJkaW1lbnNpb25zIiwiYW1uZXN0eUNhdXNlcyIsImNhbGN1bGF0ZURpbWVuc2lvblNjb3JlcyIsInJlc3BvbnNlcyIsImRpbWVuc2lvblNjb3JlcyIsImRpbWVuc2lvbkNvdW50cyIsImZvckVhY2giLCJkaW1lbnNpb24iLCJpZCIsInJlc3BvbnNlIiwibWFwcGluZ3MiLCJmaWx0ZXIiLCJtYXBwaW5nIiwicXVlc3Rpb25JZCIsInNjb3JlQ2hhbmdlIiwiYWdyZWUiLCJ3ZWlnaHQiLCJkaW1lbnNpb25JZCIsImRpbUlkIiwicmF3U2NvcmUiLCJxdWVzdGlvbkNvdW50IiwiYXZnU2NvcmVQZXJRdWVzdGlvbiIsIk1hdGgiLCJtYXgiLCJtaW4iLCJmaW5kTWF0Y2hpbmdQZXJzb25hbGl0eVR5cGUiLCJwZXJzb25hbGl0eVByb2ZpbGVzIiwic2ltaWxhcml0eVNjb3JlcyIsIk9iamVjdCIsImVudHJpZXMiLCJ0eXBlSWQiLCJwcm9maWxlIiwic2ltaWxhcml0eSIsIndlaWdodHNTdW0iLCJleHBlY3RlZFNjb3JlIiwiTnVtYmVyIiwidXNlclNjb3JlIiwiZGlmZmVyZW5jZSIsImFicyIsImJlc3RNYXRjaFR5cGVJZCIsImhpZ2hlc3RTaW1pbGFyaXR5IiwiTkVHQVRJVkVfSU5GSU5JVFkiLCJzY29yZSIsImZpbmRSZWNvbW1lbmRlZENhdXNlcyIsInBlcnNvbmFsaXR5VHlwZUlkIiwicmVjb21tZW5kYXRpb25NYXAiLCJnZW5lcmF0ZVVzZXJSZXN1bHQiLCJzZXNzaW9uSWQiLCJyZWNvbW1lbmRlZENhdXNlcyIsImdlbmVyYXRlRW5oYW5jZWRVc2VyUmVzdWx0IiwidXNlclJlc3VsdCIsInBlcnNvbmFsaXR5VHlwZSIsImZpbmQiLCJwIiwiZGltZW5zaW9uRGV0YWlscyIsIm1hcCIsImQiLCJkZXNjcmlwdGlvbiIsImhpZ2hEZXNjcmlwdGlvbiIsImxvd0Rlc2NyaXB0aW9uIiwic29ydCIsImEiLCJiIiwiY2F1c2VzIiwiY2F1c2VJZCIsImMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/data/personalityMatching.ts\n"));

/***/ })

});